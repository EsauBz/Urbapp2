Index: .idea/runConfigurations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/runConfigurations.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/runConfigurations.xml	(revision )
@@ -1,0 +1,0 @@
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Reconstruction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Reconstruction.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Reconstruction.h	(revision )
@@ -0,0 +1,82 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Reconstruction.h
+
+@brief
+    Header file for Reconstruction class.
+===============================================================================*/
+#ifndef _QCAR_RECONSTRUCTION_H_
+#define _QCAR_RECONSTRUCTION_H_
+
+#include <QCAR/QCAR.h>
+#include <QCAR/Type.h>
+#include <QCAR/Rectangle.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+/// Base interface for reconstructions with SmartTerrainBuilder in the Vuforia system.
+class QCAR_API Reconstruction : private NonCopyable
+{
+public:
+
+    /// Returns the reconstruction class' type
+    static Type getClassType();
+
+    /// Returns the instance's type
+    virtual Type getType() const = 0;
+
+    /// Set the maximum extent of the smart terrain in scene units
+    /**
+     *  The ground plane will not expand outside of this rectangle.
+     *  Objects are only created inside the rectangle. Objects on the boundary
+     *  of the rectangle will be cut off.
+     */
+    virtual bool setMaximumArea(const Rectangle& rect) = 0;
+
+    /// Get the maximum extent of the smart terrain in scene units.
+    /**
+     *  Returns false if no maximum extent has been defined.
+     */
+    virtual bool getMaximumArea(Rectangle& rect) const = 0;
+
+    /// Define how much the SmartTerrain ground plane mesh is diminished.
+    /**
+    *  Padding must be greater than or equal to 0.
+    */
+    virtual void setNavMeshPadding(float padding) = 0;
+
+    /// Smart terrain reconstruction is started or continued if it was 
+    /// previously stopped.
+    virtual bool start() = 0;
+
+    /// Smart terrain reconstruction is stopped, existing trackables are 
+    /// still tracked.
+    virtual bool stop() = 0;
+
+    /// Resets the reconstruction, clearing out existing trackables.    
+    /**
+     *  The ground plane and all objects are cleared.
+     *  The scene has to be scanned completely again.
+     */
+    virtual bool reset() = 0;
+
+    /// Returns true if the terrain and objects are being updated
+    virtual bool isReconstructing() const = 0;
+
+protected:
+    /// Destructor.
+    virtual ~Reconstruction() {}
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_RECONSTRUCTION_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetResult.h	(revision )
@@ -0,0 +1,49 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ImageTargetResult.h
+
+@brief
+    Header file for ImageTargetResult class.
+===============================================================================*/
+#ifndef _QCAR_IMAGETARGETRESULT_H_
+#define _QCAR_IMAGETARGETRESULT_H_
+
+// Include files
+#include <QCAR/ObjectTargetResult.h>
+#include <QCAR/ImageTarget.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class VirtualButtonResult;
+
+/// Result for an ImageTarget.
+class QCAR_API ImageTargetResult : public ObjectTargetResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const ImageTarget& getTrackable() const = 0;
+
+    /// Returns the number of VirtualButtons defined for this ImageTarget
+    virtual int getNumVirtualButtons() const = 0;
+
+    /// Returns the VirtualButtonResult for a specific VirtualButton
+    virtual const VirtualButtonResult* getVirtualButtonResult(int idx) const = 0;
+
+    /// Returns the VirtualButtonResult for a specific VirtualButton
+    virtual const VirtualButtonResult* getVirtualButtonResult(const char* name) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_IMAGETARGETRESULT_H_
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ app/build.gradle	(revision )
@@ -4,6 +4,11 @@
     compileSdkVersion 23
     buildToolsVersion "23.0.2"
 
+    sourceSets.main {
+        jni.srcDirs = []
+        jniLibs.srcDir "src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/lib"
+    }
+
     defaultConfig {
         applicationId "fr.turfu.urbapp2"
         minSdkVersion 16
@@ -25,4 +30,5 @@
     compile 'com.android.support:appcompat-v7:23.1.1'
     compile 'com.android.support:support-v4:23.1.1'
     compile 'com.android.support:design:23.1.1'
+    compile files('src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/java/vuforia/Vuforia.jar')
 }
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTarget.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTarget.h	(revision )
@@ -0,0 +1,68 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    CylinderTarget.h
+
+@brief
+    Header file for CylinderTarget class.
+===============================================================================*/
+#ifndef _QCAR_CYLINDERTARGET_H_
+#define _QCAR_CYLINDERTARGET_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+#include <QCAR/ObjectTarget.h>
+
+namespace QCAR
+{
+
+/// A 3D trackable object of cylindrical or conical shape.
+/**
+ *  The CylinderTarget class exposes convenience functionality for setting the
+ *  scene size of the object via any of its three defining geometric parameters:
+ *  side length, top diameter and bottom diameter. 
+ *  The object is always scaled uniformly, so changing any of its parameters 
+ *  affects all others.
+ */
+class QCAR_API CylinderTarget : public ObjectTarget
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the side length of the cylinder target (in 3D scene units).
+    virtual float getSideLength() const = 0;
+
+    /// Sets the side length of the cylinder target (in 3D scene units).
+    /**
+     *  Note that the top and bottom diameter will be scaled accordingly.
+     */
+    virtual bool setSideLength(float sideLength) = 0;
+
+    /// Returns the top diameter of the cylinder target (in 3D scene units).
+    virtual float getTopDiameter() const = 0;
+
+    /// Sets the top diameter of the cylinder target (in 3D scene units).
+    /**
+     *  Note that the height and bottom diameter will be scaled accordingly.
+     */
+    virtual bool setTopDiameter(float topDiameter) = 0;
+
+    /// Returns the bottom diameter of the cylinder target (in 3D scene units).
+    virtual float getBottomDiameter() const = 0;
+
+    /// Sets the bottom diameter of the cylinder target (in 3D scene units).
+    /**
+     *  Note that the height and top diameter will be scaled accordingly.
+     */
+    virtual bool setBottomDiameter(float bottomDiameter) = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_CYLINDERTARGET_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundConfig.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundConfig.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundConfig.h	(revision )
@@ -0,0 +1,83 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    VideoBackgroundConfig.h
+
+@brief
+    Header file for VideoBackgroundConfig struct.
+===============================================================================*/
+#ifndef _QCAR_VIDEOBACKGROUNDCONFIG_H_
+#define _QCAR_VIDEOBACKGROUNDCONFIG_H_
+
+// Include files
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+enum VIDEO_BACKGROUND_REFLECTION
+{
+    VIDEO_BACKGROUND_REFLECTION_DEFAULT,  ///< Allows the SDK to set the recommended reflection settings for the current camera
+    VIDEO_BACKGROUND_REFLECTION_ON,       ///< Overrides the SDK recommendation to force a reflection
+    VIDEO_BACKGROUND_REFLECTION_OFF       ///< Overrides the SDK recommendation to disable reflection
+};
+
+/// Video background configuration
+struct VideoBackgroundConfig
+{
+    /// Constructor to provide basic initalization. 
+    VideoBackgroundConfig()
+    {
+        mEnabled = true;
+        mPosition.data[0] = 0;
+        mPosition.data[1] = 0;
+        mSize.data[0] = 0;
+        mSize.data[1] = 0;
+        mReflection = VIDEO_BACKGROUND_REFLECTION_DEFAULT;
+    }
+
+    /// Enables/disables rendering of the video background.
+    bool mEnabled;
+
+    /// Relative position of the video background in the render target in
+    /// pixels.
+    /**
+     *  Describes the offset of the center of video background to the
+     *  center of the screen (viewport) in pixels. A value of (0,0) centers the
+     *  video background, whereas a value of (-10,15) moves the video background
+     *  10 pixels to the left and 15 pixels upwards.
+     */
+    Vec2I mPosition;
+
+    /// Width and height of the video background in pixels
+    /**
+     *  Using the device's screen size for this parameter scales the image to
+     *  fullscreen. Notice that if the camera's aspect ratio is different than
+     *  the screen's aspect ratio this will create a non-uniform stretched
+     *  image.
+     */
+    Vec2I mSize;
+
+    /// Reflection parameter to control how the video background is rendered
+    /**
+     *  By setting this to VIDEO_BACKGROUND_REFLECTION_DEFAULT, the SDK will
+     *  update the projection matrix and video background automatically to provide
+     *  the best AR mode possible for the given camera on your specific device.
+     *  For the BACK camera, this will generally result in no reflection at all.
+     *  For the FRONT camera, this will generally result in a reflection to provide
+     *  an "AR Mirror" effect.
+     *  
+     *  This can also be overridden by selecting VIDEO_BACKGROUND_REFLECTION_ON or
+     *  VIDEO_BACKGROUND_REFLECTION_OFF.  This may be desirable in advanced use
+     *  cases.
+     */
+    VIDEO_BACKGROUND_REFLECTION mReflection;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_RENDERER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordResult.h	(revision )
@@ -0,0 +1,41 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    WordResult.h
+
+@brief
+    Header file for WordResult class.
+===============================================================================*/
+#ifndef _QCAR_WORDRESULT_H_
+#define _QCAR_WORDRESULT_H_
+
+// Include files
+#include <QCAR/TrackableResult.h>
+#include <QCAR/Word.h>
+#include <QCAR/Obb2D.h>
+
+namespace QCAR
+{
+
+/// Trackable result for a Word.
+class QCAR_API WordResult : public TrackableResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents.
+    virtual const Word& getTrackable() const = 0;
+
+    /// Returns the oriented bounding box in image space of the word.
+    virtual const Obb2D& getObb() const = 0;
+};
+    
+} // namespace QCAR
+
+#endif //_QCAR_WORDRESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Prop.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Prop.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Prop.h	(revision )
@@ -0,0 +1,53 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Prop.h
+
+@brief
+    Header file for Prop class.
+===============================================================================*/
+#ifndef _QCAR_PROP_H_
+#define _QCAR_PROP_H_
+
+// Include files
+#include <QCAR/SmartTerrainTrackable.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class Obb3D;
+class Mesh;
+
+/// A trackable that refers to an unknown object on a smart terrain Surface
+/**
+ * The Prop class provides access to all data of a reconstructed object,
+ * including the mesh and the bounding box. It inherits from
+ * SmartTerrainTrackable where the Mesh represents the overall extents of
+ * the ground plane.
+ */
+class QCAR_API Prop : public SmartTerrainTrackable
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Get the axis-aligned bounding box of the Prop. 
+    /**
+     *  The bounding box will change over time.
+     */
+    virtual const Obb3D& getBoundingBox() const = 0;
+
+    /// Get the local 2D position relative to the parent SmartTerrainTrackable
+    virtual const Vec2F& getLocalPosition() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_PROP_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerResult.h	(revision )
@@ -0,0 +1,37 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    MarkerResult.h
+
+@brief
+    Header file for MarkerResult class.
+===============================================================================*/
+#ifndef _QCAR_MARKERRESULT_H_
+#define _QCAR_MARKERRESULT_H_
+
+// Include files
+#include <QCAR/TrackableResult.h>
+#include <QCAR/Marker.h>
+
+namespace QCAR
+{
+
+/// Result for a Marker.
+class QCAR_API MarkerResult : public TrackableResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const Marker& getTrackable() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MARKERRESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTarget.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTarget.h	(revision )
@@ -0,0 +1,59 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ObjectTarget.h
+
+@brief
+    Header file for the ObjectTarget Trackable type.
+===============================================================================*/
+#ifndef _QCAR_OBJECTTARGET_H_
+#define _QCAR_OBJECTTARGET_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+/// A target for tracking rigid three-dimensional bodies.
+class QCAR_API ObjectTarget : public Trackable
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the system-wide unique id of the target.
+    /**
+     *  The target id uniquely identifies an ObjectTarget across multiple
+     *  Vuforia sessions. The system wide unique id may be generated off-line.
+     *  This is opposed to the function getId() which is a dynamically
+     *  generated id and which uniquely identifies a Trackable within one run
+     *  of Vuforia only.
+     */
+    virtual const char* getUniqueTargetId() const = 0;
+
+    /// Returns the size (width, height, depth) of the target (in 3D scene units).
+    virtual Vec3F getSize() const = 0;
+
+    /// Set the size (width, height, depth) of the target (in 3D scene units).
+    /**
+     *  The dataset this target belongs to should not be active when calling
+     *  this function, otherwise it will fail. 
+     *  We expect the scale factor to be uniform, and if the given size
+     *  corresponds to non-uniform scaling based on the original size, 
+     *  we return false.
+     *  Returns true if the size was set successfully, false otherwise.
+     */
+    virtual bool setSize(const Vec3F& size) = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_OBJECTTARGET_H_
+
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTargetResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTargetResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTargetResult.h	(revision )
@@ -0,0 +1,46 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    MultiTargetResult.h
+
+@brief
+    Header file for MultiTargetResult class.
+===============================================================================*/
+#ifndef _QCAR_MULTITARGETRESULT_H_
+#define _QCAR_MULTITARGETRESULT_H_
+
+// Include files
+#include <QCAR/ObjectTargetResult.h>
+#include <QCAR/MultiTarget.h>
+
+namespace QCAR
+{
+
+/// Result for a MultiTarget.
+class QCAR_API MultiTargetResult : public ObjectTargetResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const MultiTarget& getTrackable() const = 0;
+
+    /// Returns the number of Trackables that form this MultiTarget
+    virtual int getNumPartResults() const = 0;
+
+    // Provides access to the TrackableResult for a specific part
+    virtual const TrackableResult* getPartResult(int idx) const = 0;
+
+    // Provides access to the TrackableResult for a specific part
+    virtual const TrackableResult* getPartResult(const char* name) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MULTITARGETRESULT_H_
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/modules.xml	(revision )
@@ -1,0 +1,0 @@
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerTracker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerTracker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MarkerTracker.h	(revision )
@@ -0,0 +1,65 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    MarkerTracker.h
+
+@brief
+    Header file for MarkerTracker class.
+===============================================================================*/
+#ifndef _QCAR_MARKER_TRACKER_H_
+#define _QCAR_MARKER_TRACKER_H_
+
+// Include files
+#include <QCAR/Tracker.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+// Forward Declaration
+class Marker;
+
+/// MarkerTracker class.
+/**
+ *  The MarkerTracker tracks rectangular markers and provides methods for
+ *  creating and destroying these dynamically.
+ *  Note that the methods for creating and destroying markers should not be
+ *  called while the MarkerTracker is working at the same time. Doing so will
+ *  make these methods block and wait until the MarkerTracker has finished.
+ *  The suggested way of doing this is during the execution of UpdateCallback,
+ *  which guarantees that the MarkerTracker is not working concurrently.
+ *  Alternatively the MarkerTracker can be stopped explicitly.
+ */
+class QCAR_API MarkerTracker : public Tracker
+{
+public:
+
+    /// Returns the Tracker class' type
+    static Type getClassType();
+
+    /// Creates a new Marker
+    /**
+     *  Creates a new marker of the given name, size and id. Returns the new
+     *  instance on success, NULL otherwise. Use MarkerTracker::destroyMarker
+     *  to destroy the returned Marker when it is no longer needed.
+     */   
+    virtual Marker* createFrameMarker(int markerId, const char* name,
+                                    const QCAR::Vec2F& size) = 0;
+
+    /// Destroys a Marker 
+    virtual bool destroyMarker(Marker* marker) = 0;
+
+    /// Returns the total number of Markers that have been created.
+    virtual int getNumMarkers() const = 0;
+
+    /// Returns a pointer to a Marker object
+    virtual Marker* getMarker(int idx) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MARKER_TRACKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SurfaceResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SurfaceResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SurfaceResult.h	(revision )
@@ -0,0 +1,38 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Surface.h
+
+@brief
+    Header file for Surface class.
+===============================================================================*/
+#ifndef _QCAR_SURFACERESULT_H_
+#define _QCAR_SURFACERESULT_H_
+
+// Include files
+#include <QCAR/TrackableResult.h>
+#include <QCAR/Surface.h>
+
+namespace QCAR
+{
+
+/// Result for a Surface generated by the SmartTerrainTracker.
+class QCAR_API SurfaceResult : public TrackableResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const Surface& getTrackable() const = 0;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_SURFACERESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackerManager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackerManager.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackerManager.h	(revision )
@@ -0,0 +1,73 @@
+/*===============================================================================
+Copyright (c) 2010-2015 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TrackerManager.h
+
+@brief
+    Header file for TrackerManager class.
+===============================================================================*/
+#ifndef _QCAR_TRACKER_MANAGER_H_
+#define _QCAR_TRACKER_MANAGER_H_
+
+// Include files
+#include <QCAR/Tracker.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class StateUpdater;
+
+/// TrackerManager class.
+/**
+ *  The TrackerManager singleton provides methods for accessing the trackers
+ *  available in Vuforia as well as initializing specific trackers required by the
+ *  application. See the Tracker base class for a list of available tracker
+ *  types.
+ */
+class QCAR_API TrackerManager : private NonCopyable
+{
+public:
+    /// Returns the TrackerManager singleton instance.
+    static TrackerManager& getInstance();
+
+    /// Initializes the tracker of the given type
+    /**
+     *  Initializing a tracker must not be done when the CameraDevice
+     *  is initialized or started. This function will return NULL if the
+     *  tracker of the given type has already been initialized or if the
+     *  CameraDevice is currently initialized.
+     */
+    virtual Tracker* initTracker(Type type) = 0;
+
+    /// Returns the instance of the given tracker type
+    /**
+     *  See the Tracker base class for a list of available tracker classes.
+     *  This function will return NULL if the tracker of the given type has
+     *  not been initialized.
+     */
+    virtual Tracker* getTracker(Type type) = 0;
+
+    /// Deinitializes the tracker of the given type
+    /**
+     *  Deinitializes the tracker of the given type and frees any resources
+     *  used by the tracker.
+     *  Deinitializing a tracker must not be done when the CameraDevice
+     *  is initialized or started. This function will return false if the
+     *  tracker of the given type has not been initialized or if the
+     *  CameraDevice is currently initialized.
+     */
+    virtual bool deinitTracker(Type type) = 0;
+
+    /// Returns the StateUpdater instance
+    virtual StateUpdater& getStateUpdater() = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TRACKER_MANAGER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundTextureInfo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundTextureInfo.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoBackgroundTextureInfo.h	(revision )
@@ -0,0 +1,51 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    VideoBackgroundConfig.h
+
+@brief
+    Header file for VideoBackgroundConfig struct.
+===============================================================================*/
+#ifndef _QCAR_VIDEOBACKGROUNDTEXTUREINFO_H_
+#define _QCAR_VIDEOBACKGROUNDTEXTUREINFO_H_
+
+// Include files
+#include <QCAR/Vectors.h>
+#include <QCAR/QCAR.h>
+
+namespace QCAR
+{
+
+/// Video background configuration
+struct VideoBackgroundTextureInfo
+{
+    /// Width and height of the video background texture in pixels
+    /**
+     *  Describes the size of the texture in the graphics unit
+     *  depending on the particular hardware it will be a power of two
+     *  value immediately after the image size
+     */
+    Vec2I mTextureSize;
+
+    /// Width and height of the video background image in pixels
+    /**
+     *  Describe the size of the image inside the texture. This corresponds
+     *  to the size of the image delivered by the camera
+     */
+    Vec2I mImageSize;
+
+    /// Format of the video background image
+    /**
+     *  Describe the pixel format of the camera image.
+     */
+    PIXEL_FORMAT mPixelFormat;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_VIDEOBACKGROUNDTEXTUREINFO_H_
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ app/src/main/res/values/strings.xml	(revision )
@@ -12,4 +12,11 @@
     <string name="user_summary">Changer d\'utilisateur</string>
     <string name="user_dialog">Veuillez entrer votre nom d\'utilisateur</string>
 
+
+    <!-- Resources for Augmented Reality activity-->
+    <string name="ar_validation">Activate !</string>
+    <string name="ar_instruction">Set up the image with two-touch gestures</string>
+    <string name="ar_add_image">Add image</string>
+    <string name="ar_rotate">Rotate</string>
+
 </resources>
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/misc.xml	(revision )
@@ -3,6 +3,13 @@
   <component name="EntryPointsManager">
     <entry_points version="2.0" />
   </component>
+  <component name="MavenImportPreferences">
+    <option name="generalSettings">
+      <MavenGeneralSettings>
+        <option name="mavenHome" value="Bundled (Maven 3)" />
+      </MavenGeneralSettings>
+    </option>
+  </component>
   <component name="NullableNotNullManager">
     <option name="myDefaultNullable" value="android.support.annotation.Nullable" />
     <option name="myDefaultNotNull" value="android.support.annotation.NonNull" />
\ No newline at end of file
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButtonResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButtonResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButtonResult.h	(revision )
@@ -0,0 +1,41 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    VirtualButtonResult.h
+
+@brief
+    Header file for VirtualButtonResult class.
+===============================================================================*/
+#ifndef _QCAR_VIRTUALBUTTONRESULT_H_
+#define _QCAR_VIRTUALBUTTONRESULT_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/System.h>
+#include <QCAR/VirtualButton.h>
+
+namespace QCAR
+{
+
+/// Tracking result for a VirtualButton.
+class QCAR_API VirtualButtonResult : private NonCopyable
+{
+public:
+    
+    /// Returns the corresponding VirtualButton that this result represents
+    virtual const VirtualButton& getVirtualButton() const = 0;
+
+    /// Returns true if the virtual button is pressed.
+    virtual bool isPressed() const = 0;
+
+protected:
+    virtual ~VirtualButtonResult()  {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_VIRTUALBUTTONRESULT_H_
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/gradle.xml	(revision )
@@ -3,9 +3,8 @@
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <option name="distributionType" value="LOCAL" />
+        <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
-        <option name="gradleHome" value="C:\Program Files\Android\Android Studio\gradle\gradle-2.8" />
         <option name="gradleJvm" value="1.8" />
         <option name="modules">
           <set>
\ No newline at end of file
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearUserCalibrator.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearUserCalibrator.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearUserCalibrator.h	(revision )
@@ -0,0 +1,140 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    EyewearUserCalibrator.h
+
+@brief
+    Header file for EyewearUserCalibrator class.
+===============================================================================*/
+#ifndef _QCAR_EYEWEARUSERCALIBRATOR_H_
+#define _QCAR_EYEWEARUSERCALIBRATOR_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/QCAR.h>
+#include <QCAR/EyeID.h>
+#include <QCAR/EyewearCalibrationReading.h>
+
+namespace QCAR
+{
+
+/// A class for creating custom user calibration procedures for see-through eyewear
+/**
+ *
+ * <br><b>This API is only supported in the Vuforia SDK for Digital %Eyewear.</b><br><br>
+ *
+ *  - Users of optical see-through eyewear devices need to perform a calibration
+ *    to determine how to project an augmentation such that it will appear
+ *    registered with the real world.  This calibration is both user and
+ *    device specific.  Vuforia provides a default calibration but to obtain
+ *    the best possible AR experience the user should calibrate Vuforia for
+ *    their own eyes and device.
+   
+ *  - To write your own calibration app you should draw a calibration shape
+ *    (rectangle) on the display and prompt the user to align the edges of
+ *    of the calibration shape with a Vuforia image target.  This step should
+ *    then be repeated with a different size shape.  A minimum of two steps are
+ *    required for a good result although further steps can be included to get
+ *    an improved calibration result.
+ *
+ *  - If the eyewear device is a stereo then the calibration needs to be
+ *    carried out independently on each eye.
+ *
+ *  - Millimeters must be used as the unit of measurement throughout
+ *    calibration.  The calibration image target used should have its size
+ *    specified in millimetres when initialising this object.  This size
+ *    must match the size specified in the dataset for the target and the
+ *    printed size of the target.
+ *
+ *  - The projection matrix generated by the calibration process includes
+ *    OpenGL clip planes which will cause augmentations very close or far
+ *    from the user to be clipped.
+ */
+class QCAR_API EyewearUserCalibrator : private NonCopyable
+{
+public:
+    /**
+     * Initialises the eyewear calibrator.
+     *
+     * - This function must be called before any other members of this class.
+     *
+     *  \param surfaceWidth  The width of the rendering surface that the calibration is running in
+     *  \param surfaceHeight  The height of the rendering surface that the calibration is running in 
+     *  \param targetWidth  The width of the image target being used in millimetres
+     *  \param targetHeight  The height of the image target being used in millimetres
+     *
+     *  \return True if initialisation is successful, false otherwise
+     *
+     **/
+    virtual bool init(int surfaceWidth, int surfaceHeight,
+                      int targetWidth,  int targetHeight) = 0;
+
+    /** 
+     * Gets a hint of the minimum size a calibration shape should be drawn
+     *
+     * - The smaller a calibration shape is drawn the further the user needs to
+     *   stand away from a target during calibration.  The minimum size that
+     *   can be drawn is device specific and this API provide a hint as to what
+     *   minimum scale shape is practical.
+     *
+     * \return The minimum scale of the shape in the range 0.0 - 1.0
+     **/
+    virtual float getMinScaleHint() = 0;
+
+    /**
+     * Gets a hint of the maximum size a calibration shape should be drawn
+     *  - Drawing a large calibration shape means the sides of the shape will
+     *    near to the sides of the display.  Some eyewear devices have
+     *    distortion towards the edge of the display.  This API provides a hint
+     *    as to the maximum size a calibration shape should be drawn.
+     *
+     * \return The maximum scale of the shape in the range 0.0 - 1.0
+     **/
+    virtual float getMaxScaleHint() = 0;
+
+
+    /**
+     * Gets the aspect ratio that should be used to draw a calibration shape
+     * - Some eyewear devices introduce distortion in the calibration shapes,
+     *   for example in the form of horizontal or vertical stretch.  This value
+     *   should be used to draw calibration shapes that closely match the
+     *   aspect ratio of the real world calibration target.
+     *
+     * \return The aspect ratio for calibration shapes
+     **/
+    virtual float getDrawingAspectRatio(int surfaceWidth, int surfaceHeight) const = 0;
+
+
+    /**
+     * Checks whether a device stretches the display to create a stereoscopic effect
+     *  - When a device enters 3D it may join the displays together to create one
+     *    big display.  If the resolution of the display appears the same then the
+     *    display is effectively stretched
+     *
+     * \return True if the display is stretched, otherwise false
+     **/
+    virtual bool isStereoStretched() = 0;
+
+    /**
+     * Gets a projection matrix calibrated for eyewear
+     *
+     *  - Calculates and returns a calibrated projection matrix.
+     *  - init must be called before calling this function.
+     * 
+     * \param readings  An array of calibration readings
+     * \param numReadings  The number of readings taken, poseReadings and scales must be this length
+     * \param calibrationResult  Output matrix for the calibrated matrix
+     *
+     * \return  True if the call is successful, otherwise false
+     **/
+    virtual bool getProjectionMatrix(EyewearCalibrationReading reading[],
+                                     int numReadings, Matrix44F& calibrationResult) = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_EYEWEARUSERCALIBRATOR_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/ARRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/ARRenderer.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/ARRenderer.java	(revision )
@@ -0,0 +1,180 @@
+package fr.turfu.urbapp2.AR;
+
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import android.opengl.Matrix;
+import android.util.Log;
+
+import com.qualcomm.vuforia.CameraCalibration;
+import com.qualcomm.vuforia.CameraDevice;
+import com.qualcomm.vuforia.Renderer;
+import com.qualcomm.vuforia.State;
+import com.qualcomm.vuforia.TrackableResult;
+import com.qualcomm.vuforia.Vuforia;
+
+import java.util.Stack;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import static com.qualcomm.vuforia.Tool.convertPose2GLMatrix;
+import static com.qualcomm.vuforia.Tool.getProjectionGL;
+
+
+/**
+ * Created by Julien Vuillamy on 02/03/16.
+ * This class implements the GL Renderer. It renders multiple GLOverlays to track multiple AR images simultaneously.
+ * Inspired by the UserDefinedTargetRenderer class from VuforiaSamples
+ * https://developer.vuforia.com/downloads/samples
+ */
+
+public class ARRenderer implements GLSurfaceView.Renderer{
+
+    private static final String LOGTAG = "ARRenderer" ;
+
+    //Single instance of the class
+    private static ARRenderer arRenderer ;
+
+    private static Stack<GLOverlay> overlays ;
+
+    private static float[] projectionMatrix ;
+
+    private static float[] modelViewMatrix;
+    private static float[] identityModelView;
+
+    private ARRenderer() {
+        super();
+        overlays = new Stack<>();
+    }
+
+    public static ARRenderer getInstance() {
+        if (arRenderer == null)
+            arRenderer = new ARRenderer();
+
+        return arRenderer;
+    }
+
+    @Override
+    public void onSurfaceCreated(GL10 unusedGL, EGLConfig unusedconfig) {
+
+        Log.d(LOGTAG, ": onSurfaceCreate");
+        Vuforia.onSurfaceCreated();
+
+        setModelViewMatrix();
+    }
+
+    @Override
+    public void onSurfaceChanged(GL10 unusedGL, int width, int height) {
+        Log.d(LOGTAG, " : onSurfaceChanged");
+        Vuforia.onSurfaceChanged(width, height);
+
+        CameraCalibration camCal = CameraDevice.getInstance().getCameraCalibration();
+        projectionMatrix = getProjectionGL(camCal, 0.1f, 2000.f).getData();
+
+    }
+
+    @Override
+    public void onDrawFrame(GL10 unused_gl) {
+
+        //Clear with white color
+        GLES20.glClearColor(1, 1, 1, 0);
+        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
+
+        Renderer renderer = Renderer.getInstance();
+        State state = renderer.begin();
+
+        //Render camera background
+        renderer.drawVideoBackground();
+
+        if (!overlays.isEmpty()) {
+        for (int i = 0; i < state.getNumTrackableResults(); i++) {
+            //Get the tracker result
+            Log.d(LOGTAG,"Number of Trackables : " + state.getNumTrackables());
+            Log.d(LOGTAG,"Number of Trackable results : " + state.getNumTrackableResults());
+
+            TrackableResult trackableResult = state.getTrackableResult(i);
+            trackableResult.getTrackable().startExtendedTracking();
+
+            //Get the modelView matrix
+            modelViewMatrix = convertPose2GLMatrix(trackableResult.getPose()).getData();
+
+            GLOverlay overlay = findOverlayfromTrackerName(trackableResult.getTrackable().getName());
+            if (overlay != null) {
+                overlay.render();
+            }
+        }
+        //Render first overlay if not tracked
+        if (!overlays.peek().isTracked())
+            overlays.peek().render();
+        }
+        Renderer.getInstance().end();
+
+        //Reset the modelViewMatrix to avoid any rendering with wrong modelViewMatrix
+        modelViewMatrix = null ;
+    }
+
+    private void setModelViewMatrix(){
+        identityModelView = new float[16];
+        Matrix.setIdentityM(identityModelView, 0);
+        identityModelView[5] = -1;
+    }
+
+    public void replaceOverlay(Texture t)
+    {
+        if (t == null) {
+            Log.e(LOGTAG, "Cannot create overlay with null texture");
+            return;
+        }
+        overlays.pop();
+        overlays.add(new GLOverlay(t));
+    }
+    public void createOverlay(Texture t) {
+        Log.i(LOGTAG, ": createOverlay");
+
+        if (t == null) {
+            Log.e(LOGTAG, "Cannot create overlay with null texture");
+            return;
+        }
+
+        if (!overlays.empty() && !overlays.peek().isTracked())
+        {
+            //The old top overlay is removed if not being tracked
+            overlays.pop();
+        }
+        //Add the new overlay on top of the stack
+        overlays.add(new GLOverlay(t));
+    }
+
+    //Always transforms the top of the overlays stack
+    public void transformSelectedOverlay(TransformType transformType, float value) {
+        if (!overlays.isEmpty())
+            overlays.peek().transformObject(transformType,value);
+    }
+
+    public void setTracked(String trackerName) {
+        if (!overlays.empty())
+            overlays.peek().setTracked(trackerName);
+    }
+
+    public float[] getProjection() {
+        return projectionMatrix;
+    }
+
+    public float[] getModelView(boolean isTracked) {
+        if (isTracked)
+            return modelViewMatrix;
+
+        else
+            return identityModelView;
+    }
+
+    public GLOverlay findOverlayfromTrackerName(String tn)
+    {
+        for (GLOverlay gl : overlays)
+        {
+            if (gl.isTracked() &&  gl.getTrackerName().equals(tn))
+                return gl ;
+        }
+        return null;
+    }
+}
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetBuilder.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetBuilder.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTargetBuilder.h	(revision )
@@ -0,0 +1,94 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ImageTargetBuilder.h
+
+@brief
+    Header file for ImageTargetBuilder class.
+===============================================================================*/
+#ifndef _QCAR_IMAGE_TARGET_BUILDER_H_
+#define _QCAR_IMAGE_TARGET_BUILDER_H_
+
+// Include files
+#include <QCAR/System.h>
+
+namespace QCAR
+{
+
+class TrackableSource;
+
+/// ImageTargetBuilder
+class QCAR_API ImageTargetBuilder
+{
+public:
+
+   enum FRAME_QUALITY {
+       FRAME_QUALITY_NONE = -1, ///< getFrameQualty was called oustside of scanning mode
+       FRAME_QUALITY_LOW = 0,   ///< Poor number of features for tracking
+       FRAME_QUALITY_MEDIUM,    ///< Sufficient number features for tracking
+       FRAME_QUALITY_HIGH,      ///< Ideal number of features for tracking
+   };
+   
+
+   /// Build an Image Target Trackable source from the next available camera frame 
+   /**
+    * Build an Image Target Trackable Source from the next available camera frame.
+    * This is an asynchronous process, the result of which will be available from
+    * getTrackableSource().
+    *
+    * Note, the ImageTargetBuilder class must be in scan mode for a successful
+    * target to be built.  This allows you to provide feedback to the end user
+    * as to what the quality of the current frame is before creating a target.
+    *
+    * This method will return true if the build was successfully started, and false
+    * if an invalid name or sceenSizeWidth is provided.
+    */
+   virtual bool build(const char* name, float sceneSizeWidth) = 0;
+
+
+   /// Start the scanning mode, allowing calls to getFrameQuality()
+   /**
+    * Starts the internal frame scanning process, allowing calls to getFrameQuality()
+    */
+   virtual void startScan() = 0;
+
+
+   /// Stop the scanning mode
+   /**
+    * Stop the scanning mode, getFrameQuality will return FRAME_QUALITY_NONE until
+    * startScan is called again.  Stopping scan mode will reduce the overall system
+    * utilization when not building ImageTargets.
+    */
+   virtual void stopScan() = 0;
+
+   
+   /// Get frame quality, available after startScan is called.
+   /**
+    * Will return the frame quality for the last available camera frame, a value
+    * of FRAME_QUALITY_NONE will be returned if the scanning mode was not enabled.
+    * via the startScan() method.
+    */
+   virtual FRAME_QUALITY getFrameQuality() = 0;
+
+   
+   /// Returns a trackable source object to be used in adding a new target to a dataset
+   /**
+    * This method will return a TrackableSource to be provided to the DataSet.  This 
+    * API will return NULL until a trackable source is available.  This trackable
+    * source will be provided via this api until build() is called again, at which
+    * point it will return NULL again until a successful build step has occured.
+    */
+   virtual TrackableSource* getTrackableSource() = 0;
+
+protected:
+   virtual ~ImageTargetBuilder()  {}
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_IMAGE_TARGET_BUILDER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/ARSurfaceView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/ARSurfaceView.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/ARSurfaceView.java	(revision )
@@ -0,0 +1,117 @@
+package fr.turfu.urbapp2.AR;
+
+import android.content.Context;
+import android.opengl.GLSurfaceView;
+import android.util.Log;
+import android.view.MotionEvent;
+import android.view.View;
+
+/**
+ * Created by Julien Vuillamy on 04/03/16.
+ */
+
+public class ARSurfaceView extends GLSurfaceView implements View.OnTouchListener {
+
+    private final static String LOGTAG = "ARSurfaceView";
+
+    //Instance of the renderer rendering this GLView
+    private final ARRenderer renderer;
+
+    //Variables used to control touch events
+    private int touch_number = 0;
+    private float oldDist = 1f;
+    private float oldX, oldY;
+
+    public ARSurfaceView(Context context) {
+        super(context);
+
+        //Set OpenGL to the version 2
+        setEGLContextClientVersion(2);
+        setPreserveEGLContextOnPause(true);
+        //Get the GLSurfaceView renderer
+        renderer = ARRenderer.getInstance();
+        setRenderer(renderer);
+        setOnTouchListener(this);
+    }
+
+    /**
+     * Method called by touch events and used to resize/reshape the current GLOverlay
+     * @param v
+     * @param event
+     * @return True
+     */
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+
+        Log.i(LOGTAG, "Number of fingers : " + touch_number);
+
+        switch (event.getActionMasked()) {
+            case MotionEvent.ACTION_POINTER_UP:
+            case MotionEvent.ACTION_UP:
+                touch_number--;
+                break;
+
+            case MotionEvent.ACTION_DOWN:
+            case MotionEvent.ACTION_POINTER_DOWN:
+                touch_number++;
+                if (touch_number == 2) {
+                    oldX = event.getX(1);
+                    oldY = event.getY(1);
+                    oldDist = spacing(event);
+                }
+                break;
+
+            case MotionEvent.ACTION_MOVE:
+                if (touch_number == 2) { //Two fingers defines a scale or shearing operation
+                    float newDist = spacing(event);
+                    if (newDist > 5f) {
+
+                        float varDist = newDist - oldDist;
+                        if (Math.abs(varDist)> 5f) {
+                            //Fingers are separating : scaling operation
+                            Log.i(LOGTAG, "SCALE_ACTION");
+                            float scale = newDist / oldDist ;
+                            renderer.transformSelectedOverlay(TransformType.SCALE, scale);
+                            oldX = event.getX(1);
+                            oldY = event.getY(1);
+                        } else {
+                            //Fingers are at constant distance : shearing operation
+
+                            //Variations in the two axis
+                            float varX = event.getX(1) - oldX;
+                            float varY = event.getY(1) - oldY;
+
+                            if (Math.abs(varY) > 5f) {
+                                //Horizontal variation
+                                float shear = varY / 10;
+                                renderer.transformSelectedOverlay(TransformType.SHEARH, shear);
+                            }
+                            if (Math.abs(varX) > 3f) {
+                                //Vertical variation
+                                float shear = varX / 10;
+                                renderer.transformSelectedOverlay(TransformType.SHEARV, shear);
+                            }
+                            oldX = event.getX(1);
+                            oldY = event.getY(1);
+                        }
+
+
+                        oldDist = newDist;
+                    }
+                }
+        }
+        return true;
+    }
+
+    /**
+     * Utility to mesure the spacing between two fingers
+     * @param event
+     * @return
+     */
+    private float spacing(MotionEvent event) {
+        float x = event.getX(0) - event.getX(1);
+        float y = event.getY(0) - event.getY(1);
+        return (float) Math.sqrt((double) x * x + y * y);
+    }
+
+}
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Mesh.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Mesh.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Mesh.h	(revision )
@@ -0,0 +1,67 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Mesh.h
+
+@brief
+    Header file for Mesh class.
+===============================================================================*/
+#ifndef _QCAR_MESH_H_
+#define _QCAR_MESH_H_
+
+#include <QCAR/System.h>
+#include <QCAR/Vectors.h>
+
+
+namespace QCAR
+{
+
+/// A triangle mesh contains positions and optionally normals
+class QCAR_API Mesh
+{
+public:
+
+    /// Returns the number of vertices, i.e. positions and normals
+    virtual int getNumVertices() const = 0;
+
+    /// Returns true if the mesh contains positions
+    virtual bool hasPositions() const = 0;
+
+    /// Provides access to the array of positions
+    virtual const Vec3F* getPositions() const = 0;
+    
+    /// Provides access to the array of positions
+    virtual const float* getPositionCoordinates() const = 0;
+
+    /// Returns true if the mesh contains surface normals
+    virtual bool hasNormals() const = 0;
+
+    /// Provides access to the array of surface normals
+    virtual const Vec3F* getNormals() const = 0;
+
+    /// Provides access to the array of surface normals
+    virtual const float* getNormalCoordinates() const = 0;
+
+    /// Returns true if the mesh contains texture coordinates
+    virtual bool hasUVs() const = 0;
+
+    /// Provides access to the array of texture coordinates
+    virtual const Vec2F* getUVs() const = 0;
+
+    /// Provides access to the array of texture coordinates
+    virtual const float* getUVCoordinates() const = 0;
+
+    /// Returns the number of triangles
+    virtual int getNumTriangles() const = 0;
+
+    /// Provides access to the array triangle indices
+    virtual const unsigned short* getTriangles() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MESH_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Word.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Word.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Word.h	(revision )
@@ -0,0 +1,64 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Word.h
+
+@brief
+    Header file for Word class.
+===============================================================================*/
+#ifndef _QCAR_WORD_H_
+#define _QCAR_WORD_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/Trackable.h>
+#include <QCAR/Vectors.h>
+#include <QCAR/Rectangle.h>
+#include <QCAR/Image.h>
+
+namespace QCAR
+{
+
+/// A Word represents a single element of writing.
+class QCAR_API Word : public Trackable
+{
+public:
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the Unicode character string for this word.
+    virtual const UInt16* getStringU() const = 0;
+
+    /// Returns the number of characters in the string excluding the null
+    /// terminator.
+    virtual int getLength() const = 0;
+
+    /// Returns the number of code units in the Unicode string.
+    virtual int getNumCodeUnits() const = 0;   
+
+    /// Returns the size (width and height) of the word bounding box 
+    ///(in 3D scene units).
+    virtual Vec2F getSize() const = 0;
+
+    /// Returns an image representing the bit mask of the letters in the word.
+    /**
+     * Each pixel in the image is represented by a byte (8-bit value).
+     * A value of 255 represents an empty area, i.e. a pixel not covered 
+     * by any letter of the word.
+     * If a pixel is covered by a letter, then the pixel value represents 
+     * the position of that letter in the word, i.e. 0 for the first character,
+     * 1 for the second, 2 for the third, and so on.
+     */
+    virtual const Image* getMask() const = 0;
+
+    /// Returns the bounding box of the letter at the given index.
+    virtual const Rectangle* getLetterBoundingBox(int idx) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_WORD_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/StateUpdater.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/StateUpdater.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/StateUpdater.h	(revision )
@@ -0,0 +1,58 @@
+/*===============================================================================
+Copyright (c) 2015 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other
+countries.
+
+@file
+StateUpdater.h
+
+@brief
+Header file for StateUpdater class.
+===============================================================================*/
+#ifndef _QCAR_STATE_UPDATER_H_
+#define _QCAR_STATE_UPDATER_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/NonCopyable.h>
+#include <QCAR/State.h>
+
+namespace QCAR
+{
+
+/// StateUpdater class
+/**
+*  The StateUpdater class exposes APIs for on-demand creation of new State
+*  instances. While the QCAR::UpdateCallback implements a �push� model for new
+*  State instances being made available when a new camera frame has finished
+*  processing, the StateUpdater follows a �pull� model. The StateUpdater can be
+*  used to request the latest available state asynchronously from the camera
+*  update rate, where the Trackable poses may be updated given inertial
+*  measurements since the last camera frame. On devices where inertial/
+*  predictive tracking is not available StateUpdater will simply return the
+*  latest camera-based state.
+*/
+class StateUpdater : private NonCopyable
+{
+public:
+    
+    /// Attempts to update the State from latest tracking data and returns it
+    /**
+    *  Integrates latest available inertial measurements to create the most
+    *  up-to-date State instance. Note that the State created may contain poses
+    *  that are no longer in sync with the last camera frame. Thus this function's
+    *  primary use cases are VR as well as AR on see-through Eyewear devices
+    *  where tight visual registration with a rendered video background is not
+    *  required. On devices where inertial/predictive tracking is not available
+    *  updateState() will simply return the latest camera-based state.
+    */
+    virtual State updateState() = 0;
+
+    /// Accessor for the last state created from updateState()
+    virtual State getLatestState() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_STATE_UPDATER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyeID.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyeID.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyeID.h	(revision )
@@ -0,0 +1,28 @@
+/*==============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other
+countries.
+
+@file 
+    EyeID.h
+
+@brief
+    Header file for EyeID enum. 
+==============================================================================*/
+#ifndef _QCAR_EYEID_H_
+#define _QCAR_EYEID_H_
+
+namespace QCAR
+{
+
+enum EYEID
+{
+    EYEID_MONOCULAR = 0,    ///< Identifier for a monocular (single) eye
+    EYEID_LEFT = 1,         ///< Identifier for the left eye
+    EYEID_RIGHT = 2,        ///< Identifier for the right eye
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_EYEWEAR_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Matrices.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Matrices.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Matrices.h	(revision )
@@ -0,0 +1,32 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Matrices.h
+
+@brief
+    Header file for Matrix34F and Matrix44F structs.
+===============================================================================*/
+#ifndef _QCAR_MATRIX_H_
+#define _QCAR_MATRIX_H_
+
+namespace QCAR
+{
+
+/// Matrix with 3 rows and 4 columns of float items
+struct Matrix34F {
+    float data[3*4];   ///< Array of matrix items
+};
+
+
+/// Matrix with 4 rows and 4 columns of float items
+struct Matrix44F {
+    float data[4*4];   ///< Array of matrix items
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MATRIX_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Marker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Marker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Marker.h	(revision )
@@ -0,0 +1,56 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Marker.h
+
+@brief
+    Header file for Marker class.
+===============================================================================*/
+#ifndef _QCAR_MARKER_H_
+#define _QCAR_MARKER_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+/// A rectangular marker
+class QCAR_API Marker : public Trackable
+{
+public:
+    /// Type of markers
+    enum MARKER_TYPE
+    {
+        INVALID,            ///< Invalid marker type
+        ID_FRAME            ///< An id-encoded marker that stores the id
+                            ///< in the frame
+    };
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the size of the marker in 3D scene units.
+    virtual Vec2F getSize() const = 0;
+
+    /// Sets a new size (in 3D scene units) for the marker.
+    virtual bool setSize(const Vec2F& size) = 0;
+
+    /// Returns the marker ID (as opposed to the trackable's id, which can be
+    /// queried using getId())
+    virtual int getMarkerId() const = 0;
+
+    /// Returns the marker type (as opposed to the trackable's type, which can
+    /// be queried using getType())
+    virtual MARKER_TYPE getMarkerType() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MARKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Frame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Frame.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Frame.h	(revision )
@@ -0,0 +1,74 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Frame.h
+
+@brief
+    Header file for Frame class.
+===============================================================================*/
+#ifndef _QCAR_FRAME_H_
+#define _QCAR_FRAME_H_
+
+// Include files
+#include <QCAR/QCAR.h>
+
+namespace QCAR
+{
+
+// Forward declarations
+class Image;
+class FrameData;
+
+/// Frame is a collection of different representations of a single
+/// camerasnapshot
+/**
+ *  A Frame object can include an arbitrary number of image representations in
+ *  different formats or resolutions together with a time stamp and frame index.
+ *  Frame implements the RAII pattern: A newly created frame holds
+ *  new image data whereas copies of the share this data. The image data held by
+ *  Frame exists as long as one or more Frame objects referencing this image
+ *  data exist.
+ */
+class QCAR_API Frame
+{
+public:
+    /// Creates a new frame
+    Frame();
+
+    /// Creates a reference to an existing frame
+    Frame(const Frame& other);
+
+    /// Destructor
+    ~Frame();
+
+    /// Thread save assignment operator
+    Frame& operator=(const Frame& other);
+
+    /// A time stamp that defines when the original camera image was shot
+    /**
+     *  Value in seconds representing the offset to application startup time.
+     *  Independent from image creation the time stamp always refers to the time
+     *  the camera image was shot.
+     */
+    double getTimeStamp() const;
+
+    /// Index of the frame
+    int getIndex() const;
+
+    /// Number of images in the images-array
+    unsigned int getNumImages() const;
+
+    /// Read-only access to an image
+    const Image* getImage(int idx) const;
+
+protected:
+    FrameData* mData;
+};
+
+} // namespace QCAR
+
+#endif // _QCAR_FRAME_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordList.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordList.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/WordList.h	(revision )
@@ -0,0 +1,192 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    WordList.h
+
+@brief
+    Header file for WordList class.
+===============================================================================*/
+#ifndef _QCAR_WORD_LIST_H_
+#define _QCAR_WORD_LIST_H_
+
+#include <QCAR/System.h>
+#include <QCAR/NonCopyable.h>
+#include <QCAR/QCAR.h>
+
+namespace QCAR
+{
+
+/// A list of words that the TextTracker can detect and track
+/**
+ *  The WordList represents the set of detectable Words. This list is
+ *  loaded from a binary data file using loadWordList.
+ *  By default a WordList for the English language is provided with the SDK.
+ *  The application may choose to add a small set of additional custom words to
+ *  the WordList using the APIs below.
+ *  The filter list allows an application to specify a subset of Words
+ *  from the WordList that will be detected and tracked. 
+ *  Due to the large number of words in the WordList it is not possible to
+ *  query the contents of the WordList at run-time.
+ *  Note that the TextTracker needs to be stopped prior to making modifications
+ *  to the WordList.
+ */
+class QCAR_API WordList : public NonCopyable
+{
+public:
+
+    /// Deprecated enum.  Use QCAR::STORAGE_TYPE instead.
+    /// Types of storage locations
+    enum STORAGE_TYPE {
+        STORAGE_APP,            ///< Storage private to the application
+        STORAGE_APPRESOURCE,    ///< Storage for assets bundled with the
+                                ///< application
+        STORAGE_ABSOLUTE        ///< Helper type for specifying an absolute path
+    };
+
+    /// Types of filter modes
+    enum FILTER_MODE {
+        FILTER_MODE_NONE,       ///< Word filtering is disabled
+        FILTER_MODE_BLACK_LIST, ///< Prevent specific words from being detected
+        FILTER_MODE_WHITE_LIST  ///< Enable selected words only to be detected
+    };
+
+    /// Loads the word list from a binary file at the specified path 
+    /// and storage location.
+    /**
+     *  Loads the word list from the given input file.
+     *  Returns false if the path is NULL.
+     */
+    virtual bool loadWordList(const char* path, QCAR::STORAGE_TYPE storageType) = 0;
+
+    /// Loads the word list from a binary file at the specified path 
+    /// and storage location.
+    /**
+     *  Loads the word list from the given input file.
+     *  Returns false if the path is NULL.
+     *  
+     *  This version is now deprecated, please use QCAR::STORAGE_TYPE based 
+     *  method instead.
+     */
+    virtual bool loadWordList(const char* path, STORAGE_TYPE storageType) = 0;
+
+    /// Loads a set of custom words from a plain text file
+    /**
+     *  The word list is extended with the custom words in the plain text file.
+     *  Each word must be between 2-45 characters in length. Returns the
+     *  number of loaded custom words. The text file shall be encoded in UTF-8.
+     *  If path is NULL the return value is -1.
+     */
+    virtual int addWordsFromFile(const char* path, QCAR::STORAGE_TYPE storageType) = 0;
+
+    /// Loads a set of custom words from a plain text file
+    /**
+     *  The word list is extended with the custom words in the plain text file.
+     *  Each word must be between 2-45 characters in length. Returns the
+     *  number of loaded custom words. The text file shall be encoded in UTF-8.
+     *  If path is NULL the return value is -1.
+     *  
+     *  This version is now deprecated, please use QCAR::STORAGE_TYPE based 
+     *  method instead.
+     */
+    virtual int addWordsFromFile(const char* path, STORAGE_TYPE storageType) = 0;
+
+    /// Add a single custom word to the word list (Unicode)
+    /**
+     *  Use containsWord to check if the word is already in the word list prior
+     *  calling this.
+     *  Returns false if word is NULL;
+     */
+    virtual bool addWordU(const UInt16* word) = 0;
+
+    /// Remove a custom word from the word list (Unicode)
+    virtual bool removeWordU(const UInt16* word) = 0;
+
+    /// Returns true if the given word is present in the WordList (Unicode)
+    /**
+     *  This function can be used to check if a word already exists in the
+     *  WordList prior to adding it as a custom word.
+     *  Returns false if word is NULL;
+     */
+    virtual bool containsWordU(const UInt16* word) = 0;
+
+    /// Clears the word list as well as the filter list.
+    /**
+     *  Call this to reset the word list and release all acquired system
+     *  resources.
+     *  Return false if word is NULL;
+     */
+    virtual bool unloadAllLists() = 0;
+
+    /// Sets the mode for the filter list
+    /**
+     *  The filter list allows an application to specify a subset of Words
+     *  from the word list that will be detected and tracked. It can do this
+     *  in two modes of operation. In black list mode, any word in the filter
+     *  list will be prevented from being detected. In the white list mode,
+     *  only words in the the filter list can be detected.
+     *  By default the filter mode is FILTER_MODE_NONE where no words are
+     *  filtered.
+     */
+    virtual bool setFilterMode(FILTER_MODE mode) = 0;
+
+    /// Returns the filter mode.
+    virtual FILTER_MODE getFilterMode() const = 0;
+
+    /// Add a single word to the filter list (Unicode)
+    /**
+     *  Adds a word to the filter list.
+     *  Returns true if successful, false if unsuccessful or if word
+     *  is NULL.
+     */
+    virtual bool addWordToFilterListU(const UInt16* word) = 0;
+
+    /// Remove a word from the filter list (Unicode)
+    /**
+     *  Remove a word from the filter list
+     *  Returns true if successful, false if unsuccessful or if word
+     *  is NULL.
+     */
+    virtual bool removeWordFromFilterListU(const UInt16* word) = 0;
+
+    /// Clear the filter list.
+    virtual bool clearFilterList() = 0;
+
+    /// Loads the filter list from a plain text file.
+    /**
+     *  The text file shall be encoded in UTF-8.
+     *  Returns false if the filter list cannot be loaded.  Note
+     *  some words may have been added to the filter list so it
+     *  may be necessary to call getFilterListWordCount to find
+     *  out what, if any, words have been loaded by this routine
+     *  if it fails.
+     *  
+     *  This version is now deprecated, please use QCAR::STORAGE_TYPE based 
+     *  method instead.
+     */
+    virtual bool loadFilterList(const char* path, STORAGE_TYPE storageType) = 0;
+
+    /// Loads the filter list from a plain text file.
+    /**
+     *  The text file shall be encoded in UTF-8.
+     *  Returns false if the filter list cannot be loaded.  Note
+     *  some words may have been added to the filter list so it
+     *  may be necessary to call getFilterListWordCount to find
+     *  out what, if any, words have been loaded by this routine
+     *  if it fails.
+     */
+    virtual bool loadFilterList(const char* path, QCAR::STORAGE_TYPE storageType) = 0;
+
+    /// Query the number of words in the filter list.
+    virtual int getFilterListWordCount() = 0;
+    
+    /// Return the ith element in the filter list (Unicode)
+    virtual const UInt16* getFilterListWordU(int i) = 0;
+
+};
+} // namespace QCAR
+
+#endif /* _QCAR_WORD_LIST_H_ */
Index: app/src/main/java/fr/turfu/urbapp2/AR/TransformType.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/TransformType.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/TransformType.java	(revision )
@@ -0,0 +1,10 @@
+package fr.turfu.urbapp2.AR;
+
+/**
+ * Created by Julien Vuillamy on 16/03/16.
+ */
+public enum TransformType {
+    SCALE,
+    SHEARH,
+    SHEARV,
+}
Index: app/src/main/java/fr/turfu/urbapp2/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/MainActivity.java	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ app/src/main/java/fr/turfu/urbapp2/MainActivity.java	(revision )
@@ -79,15 +79,20 @@
      */
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
+
+        Intent intent ;
+
         switch (item.getItemId()) {
             case R.id.home:
                 return true;
 
             case R.id.virtual_reality:
+                intent = new Intent(this, AugmentedRealityActivity.class);
+                startActivity(intent);
                 return true;
 
             case R.id.settings:
-                Intent intent = new Intent(this, SettingsActivity.class);
+                intent = new Intent(this, SettingsActivity.class);
                 startActivity(intent);
                 return true;
 
Index: app/src/main/java/fr/turfu/urbapp2/SettingsActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/SettingsActivity.java	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ app/src/main/java/fr/turfu/urbapp2/SettingsActivity.java	(revision )
@@ -53,13 +53,16 @@
      */
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
+        Intent intent ;
         switch (item.getItemId()) {
             case R.id.home:
-                Intent intent = new Intent(this, MainActivity.class);
+                intent = new Intent(this, MainActivity.class);
                 startActivity(intent);
                 return true;
 
             case R.id.virtual_reality:
+                intent = new Intent(this, AugmentedRealityActivity.class);
+                startActivity(intent);
                 return true;
 
             case R.id.settings:
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationReading.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationReading.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationReading.h	(revision )
@@ -0,0 +1,36 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    EyewearCalibrationReading.h
+
+@brief
+    Header file for EyewearCalibrationReading struct.
+===============================================================================*/
+#ifndef _QCAR_EYEWEARCALIBRATIONREADING_H_
+#define _QCAR_EYEWEARCALIBRATIONREADING_H_
+
+#include <QCAR/Matrices.h>
+
+namespace QCAR
+{
+
+/// Structure for an eyewear calibration reading to be used with EyewearUserCalibration
+struct EyewearCalibrationReading
+{
+    /// Pose matrix from a TrackableResult
+    Matrix34F mPose;
+    /// A scale in the range 0.0 - 1.0 that should specify the amount of rendering surface height the calibration shape fills
+    float mScale;
+    /// A position in the range -1.0 to 1.0 that specifies the horizontal center of the calibration shape on the rendering surface
+    float mCenterX;
+    /// A position in the range -1.0 to 1.0 that specifies the vertical center of the calibration shape on the rendering surface
+    float mCenterY;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_EYEWEARCALIBRATIONREADING_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ReconstructionFromTarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ReconstructionFromTarget.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ReconstructionFromTarget.h	(revision )
@@ -0,0 +1,69 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ReconstructionFromTarget.h
+
+@brief
+    Header file for ReconstructionFromTarget class.
+===============================================================================*/
+#ifndef _QCAR_RECONSTRUCTIONFROMTARGET_H_
+#define _QCAR_RECONSTRUCTIONFROMTARGET_H_
+
+#include <QCAR/QCAR.h>
+#include <QCAR/Reconstruction.h>
+#include <QCAR/Box3D.h>
+#include <QCAR/Trackable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/Type.h>
+
+namespace QCAR
+{
+
+
+/// A reconstruction of a plane with object(s) on top using an initialization 
+/// target.
+class QCAR_API ReconstructionFromTarget : public Reconstruction
+{
+public:
+    /// Returns the reconstruction class' type
+    static Type getClassType();
+
+    /// Define the trackable which is used for starting smart terrain.
+    /**
+     *  The occluderVolume is an axis-aligned box, which defines the area 
+     *  where the table is occluded by the target and its surrounding object.
+     */
+    virtual bool setInitializationTarget(const Trackable* trackable,
+                                         const Box3D& occluderVolume) = 0;
+
+    /// Define trackable which is used for starting smart terrain.
+    /**
+     *  The occluderVolume is an axis-aligned box, which defines the area 
+     *  where the table is occluded by the target and its surrounding object.     
+     *  offsetToOccluderPose is a pose matrix that allows to define a
+     *  translational offset and rotation of the occluder volume with respect
+     *  to the initialization target.
+     */
+    virtual bool setInitializationTarget(const Trackable* trackable,
+                                         const Box3D& occluderVolume,
+                                         const Matrix34F& offsetToOccluderPose) = 0;
+
+    /// Returns the trackable used for initialization.
+    /**
+     *  Returns null if no initialization target has been defined.
+     */
+    virtual const Trackable* getInitializationTarget() const = 0;
+
+protected:
+    virtual ~ReconstructionFromTarget() {}
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_RECONSTRUCTIONFROMTARGET_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationProfileManager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationProfileManager.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/EyewearCalibrationProfileManager.h	(revision )
@@ -0,0 +1,116 @@
+/*==============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other
+countries.
+
+@file 
+    EyewearCalibrationProfileManager.h
+
+@brief
+    Header file for EyewearCalibrationProfileManager class.
+==============================================================================*/
+
+#ifndef _QCAR_EYEWEAR_CALIBRATION_PROFILE_MANAGER_H_
+#define _QCAR_EYEWEAR_CALIBRATION_PROFILE_MANAGER_H_
+
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/EyeID.h>
+
+namespace QCAR
+{
+
+/// Class that provides functionality to manage calibration profiles for see-through devices.
+/**
+ *
+ * <br><b>This API is only supported in the Vuforia SDK for Digital %Eyewear.</b><br><br>
+ *
+ * AR calibration for see-through devices is specific to the user and device,
+ * this class provides functionality to manage multiple user calibration profiles.
+ * 
+ * - Calibration profiles are numbered 0 (the fixed default profile) and then
+ *   user defined profiles 1 to \link getMaxCount() \endlink.
+ *   At present the SDK supports a maximum of 10 user profiles.
+ * 
+ * - A default profile is always present and has the special profile ID of 0.
+ *
+ * - The stored calibration for a profile is retrieved by a call to 
+ *   Eyewear.getProjectionMatrix.
+ *
+ * - An active profile can be set (see \link setActiveProfile \endlink) after
+ *   which the calibration data for that profile will be returned by default
+ *   when calling Eyewear.getProjectionMatrix.
+ */
+class QCAR_API EyewearCalibrationProfileManager : private NonCopyable
+{
+public:
+
+    /// Get the number of profile slots provided.
+    /**
+     * At present the SDK supports a maximum of 10 user profiles, this may
+     * change in future SDK releases.
+     */
+    virtual int getMaxCount() const = 0;
+
+    /// Get the number of user calibration profiles stored.
+    /**
+     * Use this method when building a profile selection UI to get the number of
+     * profiles that the user can select from.
+     * \return a number between 0 and \link getMaxCount() \endlink.
+     */
+    virtual int getUsedCount() const = 0;
+
+    /// Returns true if the specified profile slot contains data.
+    virtual bool isProfileUsed(const int profileID) const = 0;
+
+    /// Get the ID of the active user calibration profile.
+    /**
+     * \return a number between 0 and \link getMaxCount() \endlink.
+     */
+    virtual int getActiveProfile() const = 0;
+
+    /// Set a calibration profile as active.
+    /**
+     * \param profileID a number between 1  and \link getMaxCount() \endlink.
+     * \return true if the active profile is changed, false otherwise (e.g. if the specified profile is not valid)
+     */
+    virtual bool setActiveProfile(const int profileID) = 0;
+    
+    /// Get the projection matrix for the specified profile and eye.
+    /**
+     * \param profileID a number between 0  and \link getMaxCount() \endlink.
+     * \param eyeID the Eye to retrieve the projection matrix for, one of \link EYEID_MONOCULAR  \endlink, \link EYEID_LEFT \endlink or \link EYEID_RIGHT \endlink.
+     * \return the stored projection matrix, will contain all 0's if no data is stored for the profile.
+     */
+    virtual Matrix44F getProjectionMatrix(const int profileID, const EYEID eyeID) const = 0;
+
+    /// Store a projection matrix to a calibration profile.
+    /**
+     * \param profileID a number between 1  and \link getMaxCount() \endlink.
+     * \param eyeID the Eye that this projection matrix is calibrated for, one of \link EYEID_MONOCULAR  \endlink, \link EYEID_LEFT \endlink or \link EYEID_RIGHT \endlink.
+     * \param projectionMatrix the projection matrix to store
+     * \return true if the new projection matrix was stored successfully, false otherwise.
+     */
+    virtual bool setProjectionMatrix(const int profileID, const EYEID eyeID, const Matrix44F& projectionMatrix) = 0;
+
+    /// Get the display name associated with a profile.
+    /**
+     * \return a unicode string, if no display name has been provided for the specified profile an empty string will be returned.
+     */
+    virtual const UInt16* getProfileName(const int profileID) const = 0;
+
+    /// Set a display name associated with a profile.
+    virtual bool setProfileName(const int profileID, const UInt16* name) = 0;
+
+    /// Delete all stored data for the specified profile.
+    /**
+     * If the specified profile was the active profile then the default profile becomes active.
+     */
+    virtual bool clearProfile(const int profileID) = 0;
+    
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_EYEWEAR_CALIBRATION_PROFILE_MANAGER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TextTracker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TextTracker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TextTracker.h	(revision )
@@ -0,0 +1,98 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TextTracker.h
+
+@brief
+    Header file for TextTracker class.
+===============================================================================*/
+#ifndef _QCAR_TEXT_TRACKER_H_
+#define _QCAR_TEXT_TRACKER_H_
+
+// Include files
+#include <QCAR/Tracker.h>
+#include <QCAR/Vectors.h>
+#include <QCAR/WordList.h>
+#include <QCAR/Rectangle.h>
+
+namespace QCAR
+{
+
+/// The TextTracker controls the text recognition and tracking sub-system 
+/// of Vuforia.
+/**
+ *  The TextTracker detects and tracks a single or multiple words in six
+ *  degrees of freedom (6DOF).
+ */
+class QCAR_API TextTracker : public Tracker
+{
+public:
+    
+    enum UP_DIRECTION
+    {
+        REGIONOFINTEREST_UP_IS_0_HRS     = 1,
+        REGIONOFINTEREST_UP_IS_3_HRS     = 2,
+        REGIONOFINTEREST_UP_IS_6_HRS     = 3,
+        REGIONOFINTEREST_UP_IS_9_HRS     = 4
+    };
+
+    /// Returns the Tracker class' type
+    static Type getClassType();
+
+    /// Defines the area of the image where text can be detected and tracked.
+    /**
+     *  Allows to define rectangular regions that represent the
+     *  area where text can be detected and tracked respectively.
+     *  For optimal performance the detection window should be kept small.
+     *  Larger detection windows will result in longer detection times and may
+     *  affect the user experience on some devices. A recommended detection
+     *  window size is shown in the sample application.
+     *  There is no performance impact to tracking text across the full camera
+     *  image, but it may make sense to limit the tracking area if only parts
+     *  of the camera image are visible to the user.
+     *  The regions are defined in pixel units in the space defined by
+     *  the input camera image. Please query the VideoMode from the 
+     *  CameraDevice to query the resolution of the input camera image.
+     *  Note that the detection window must be fully contained in the tracking
+     *  window for this operation to succeed.
+     */
+    virtual bool setRegionOfInterest(const RectangleInt& detectionROI,
+                                     const RectangleInt& trackingROI,
+                                     const UP_DIRECTION upDirection) = 0;
+
+    /// Returns the area of the input camera image where text can be detected.
+    /**
+     *  If no region of interest has been set using setRegionOfInterest, then
+     *  the TextTracker will use a default sub-region of the full camera image. 
+     *  In this case this function will only return valid values 
+     *  after the first camera frame has been processed.
+     */
+    virtual void getRegionOfInterest(RectangleInt& detectionROI,
+                                     RectangleInt& trackingROI,
+                                     UP_DIRECTION& upDirection) const = 0;
+
+    /// Returns the area of the input camera image where text can be detected.
+    /**
+     *  Please note that getRegionOfInterest(RectangleInt&, RectangleInt&,
+     *  unsigned int&) is deprecated. Use getRegionOfInterest(RectangleInt&,
+     *  RectangleInt&, UP_DIRECTION&) instead.
+     *  If no region of interest has been set using setRegionOfInterest, then
+     *  the TextTracker will use a default sub-region of the full camera image. 
+     *  In this case this function will only return valid values 
+     *  after the first camera frame has been processed.
+     */
+    virtual void getRegionOfInterest(RectangleInt& detectionROI,
+                                     RectangleInt& trackingROI,
+                                     unsigned int& upDirection) const = 0;
+
+    /// Returns the WordList associated to this tracker.
+    virtual WordList* getWordList() = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TEXT_TRACKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTracker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTracker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTracker.h	(revision )
@@ -0,0 +1,119 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ObjectTracker.h
+
+@brief
+    Header file for ObjectTracker class.
+===============================================================================*/
+#ifndef _QCAR_OBJECT_TRACKER_H_
+#define _QCAR_OBJECT_TRACKER_H_
+
+// Include files
+#include <QCAR/Tracker.h>
+
+namespace QCAR
+{
+
+// Forward Declaration
+class Trackable;
+class DataSet;
+class ImageTargetBuilder;
+class TargetFinder;
+
+/// ObjectTracker class.
+/**
+ *  The ObjectTracker tracks ObjectTargets, ImageTargets, CylinderTargets
+ *  or MultiTargets contained in a DataSet. 
+ *  The ObjectTracker class provides methods for creating, activating and
+ *  deactivating datasets. Note that methods for activating and deactivating 
+ *  datasets should not be called while the ObjectTracker is working at the 
+ *  same time. Doing so will make these methods block and wait until the 
+ *  tracker has finished.
+ *  The suggested way of swapping datasets is during the execution of
+ *  UpdateCallback, which guarantees that the ObjectTracker is not working
+ *  concurrently. Alternatively the ObjectTracker can be stopped explicitly.
+ *  However, this is a very expensive operation.
+ */
+class QCAR_API ObjectTracker : public Tracker
+{
+public:
+
+    /// Returns the Tracker class' type
+    static Type getClassType();
+
+    /// Factory function for creating an empty dataset.
+    /**
+     *  Returns the new instance on success, NULL otherwise. Use
+     *  DataSet::destroyDataSet() to destroy a DataSet that is no longer needed.
+     */      
+    virtual DataSet* createDataSet() = 0;
+
+    /// Destroys the given dataset and releases allocated resources.
+    /// Returns false if the given dataset is currently active.
+    virtual bool destroyDataSet(DataSet* dataset) = 0;
+
+    /// Activates the given dataset.
+    /**
+     *  This function will return true if the DataSet was successfully 
+     *  activated and false otherwise.
+     *  The recommended way to activate datasets is during the execution of the
+     *  UpdateCallback, which guarantees that the ObjectTracker is not working
+     *  concurrently.
+     */    
+    virtual bool activateDataSet(DataSet* dataset) = 0;
+    
+    /// Deactivates the given dataset.
+    /**
+     *  This function will return true if the DataSet was successfully
+     *  deactivated and false otherwise (E.g. because this dataset is not
+     *  currently active).
+     *  The recommended way to deactivate datasets is during the execution of 
+     *  the UpdateCallback, which guarantees that the ObjectTracker is not 
+     *  working concurrently.
+     */    
+    virtual bool deactivateDataSet(DataSet* dataset) = 0;
+
+    /// Returns the idx-th active dataset. Returns NULL if no DataSet has
+    /// been activated or if idx is out of range.
+    virtual DataSet* getActiveDataSet(const int idx = 0) = 0;
+
+    /// Returns the number of currently activated dataset. 
+    virtual int getActiveDataSetCount() const = 0;
+
+    /// Returns instance of ImageTargetBuilder to be used for generated
+    /// target image from current scene.
+    virtual ImageTargetBuilder* getImageTargetBuilder() = 0;
+    
+    /// Returns instance of TargetFinder to be used for retrieving
+    /// targets by cloud-based recognition.
+    virtual TargetFinder* getTargetFinder() = 0;
+
+    ///  Persist/Reset Extended Tracking
+    /**
+     *  In persistent Extended Tracking mode, the environment map will only
+     *  ever be reset when the developer calls resetExtendedTracking().
+     *  This function will return true if persistent Extended Tracking
+     *  was set successfully (or was already set to the specified value)
+     *  and false otherwise.
+     */
+    virtual bool persistExtendedTracking(bool on) = 0;
+ 
+    /// Resets environment map for Extended Tracking
+    /**
+     *  Environment map can only be reset by the developer if persistent
+     *  extended tracking is enabled.
+     *  This function will return true if environment map was reset
+     *  successfully and false otherwise.
+     */
+    virtual bool resetExtendedTracking() = 0;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_OBJECT_TRACKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tool.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tool.h	(revision )
@@ -0,0 +1,113 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Tool.h
+
+@brief
+    Header file for global Tool functions.
+===============================================================================*/
+#ifndef _QCAR_TOOL_H_
+#define _QCAR_TOOL_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+// Forward declarations
+class CameraCalibration;
+
+/// Tool functions
+namespace Tool
+{
+    /// Returns a 4x4 col-major OpenGL model-view matrix from a 3x4 Vuforia pose
+    /// matrix.
+    /**
+     *  Vuforia uses 3x4 row-major matrices for pose data. convertPose2GLMatrix()
+     *  takes such a pose matrix and returns an OpenGL compatible model-view
+     *  matrix.
+     */
+    QCAR_API Matrix44F convertPose2GLMatrix(const Matrix34F& pose);
+
+    /// Returns a 4x4 col-major OpenGL projection matrix from a 3x4 Vuforia projection
+    /// matrix.
+    /**
+    *  Vuforia uses 3x4 row-major matrices for projection data. convertProjection2GLMatrix()
+    *  takes such a projection matrix and returns an OpenGL compatible projection matrix.
+    */
+    QCAR_API Matrix44F convertProjection2GLMatrix(const Matrix34F& projection, float nearPlane, float farPlane);
+
+    /// Returns an OpenGL style projection matrix.
+    QCAR_API Matrix44F getProjectionGL(const CameraCalibration& calib,
+                                       float nearPlane, float farPlane);
+
+    /// Projects a 3D scene point into the camera image(device coordinates)
+    /// given a pose in form of a 3x4 matrix.
+    /**
+     *  The projectPoint() function takes a 3D point in scene coordinates and
+     *  transforms it using the given pose matrix. It then projects it into the
+     *  camera image (pixel coordinates) using the given camera calibration.
+     *  Note that camera coordinates are usually different from screen
+     *  coordinates, since screen and camera resolution can be different.
+     *  Transforming from camera to screen coordinates requires another
+     *  transformation using the settings applied to the Renderer via the
+     *  VideoBackgroundConfig structure.
+     */
+    QCAR_API Vec2F projectPoint(const CameraCalibration& calib,
+                                const Matrix34F& pose, const Vec3F& point);
+
+    /// Project a camera coordinate down to a plane aligned on the x-y plane with 
+    /// the given pose.  Returns the offset along the plane from its origin.
+    QCAR_API Vec2F projectPointToPlaneXY(const CameraCalibration& calib,
+                                         const Matrix34F& pose, 
+                                         const Vec2F& screenPoint);
+
+    /// Multiplies two Vuforia pose matrices
+    /**
+     *  In order to apply a transformation A on top of a transformation B,
+     *  perform: multiply(B,A).
+     */
+    QCAR_API Matrix34F multiply(const Matrix34F& matLeft,
+                                const Matrix34F& matRight);
+
+    /// Multiplies two Vuforia-style 4x4-matrices (row-major order)
+    QCAR_API Matrix44F multiply(const Matrix44F& matLeft,
+                                const Matrix44F& matRight);
+
+    /// Multiplies 1 vector and 1 Vuforia-style 4x4-matrix (row-major order)
+    QCAR_API Vec4F multiply(const Vec4F& vec,
+                            const Matrix44F& mat);
+
+    /// Multiplies 1 Vuforia-style 4x4-matrices (row-major order) and 1 vector
+    QCAR_API Vec4F multiply(const Matrix44F& mat,
+                            const Vec4F& vec);
+
+    /// Multiplies two GL-style matrices (col-major order)
+    QCAR_API Matrix44F multiplyGL(const Matrix44F& matLeft,
+                                  const Matrix44F& matRight);
+
+    /// Sets the translation part of a 3x4 pose matrix
+    QCAR_API void setTranslation(Matrix34F& pose,
+                                 const Vec3F& translation);
+
+    /// Sets the rotation part of a 3x4 pose matrix using axis-angle as input
+    /**
+     *  The axis parameter defines the 3D axis around which the pose rotates.
+     *  The angle parameter defines the angle in degrees for the rotation
+     *  around that axis.
+     */
+    QCAR_API void setRotation(Matrix34F& pose,
+                              const Vec3F& axis, float angle);
+
+} // namespace Tool
+
+} // namespace QCAR
+
+#endif //_QCAR_TOOL_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTarget.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/MultiTarget.h	(revision )
@@ -0,0 +1,107 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    MultiTarget.h
+
+@brief
+    Header file for MultiTarget class.
+===============================================================================*/
+#ifndef _QCAR_MULTITARGET_H_
+#define _QCAR_MULTITARGET_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+#include <QCAR/ObjectTarget.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/Trackable.h>
+
+namespace QCAR
+{
+
+// Forward declarations
+struct Matrix34F;
+
+/// A set of multiple targets with a fixed spatial relation
+/**
+ *  Methods to modify a MultiTarget must not be called while the
+ *  corresponding DataSet is active. The dataset must be deactivated first
+ *  before reconfiguring a MultiTarget.
+ */
+class QCAR_API MultiTarget : public ObjectTarget
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the number of Trackables that form the MultiTarget.
+    virtual int getNumParts() const = 0;
+
+    /// Provides write access to a specific Trackable.
+    /**
+     *  Returns NULL if the index is invalid.
+     */
+    virtual Trackable* getPart(int idx) = 0;
+
+    /// Provides read-only access to a specific Trackable.
+    /**
+     *  Returns NULL if the index is invalid.
+     */
+    virtual const Trackable* getPart(int idx) const = 0;
+
+    /// Provides write access to a specific Trackable.
+    /**
+     *  Returns NULL if no Trackable with the given name exists
+     *  in the MultiTarget.
+     */
+    virtual Trackable* getPart(const char* name) = 0;
+
+    /// Provides read-only access to a specific Trackable.
+    /**
+     *  Returns NULL if no Trackable with the given name exists
+     *  in the MultiTarget.
+     */
+    virtual const Trackable* getPart(const char* name) const = 0;
+
+    /// Adds a Trackable to the MultiTarget.
+    /**
+     *  Returns the index of the new part on success.
+     *  Returns -1 in case of error, e.g. when adding a Part that is already
+     *  added or if the corresponding DataSet is currently active. Use the
+     *  returned index to set the Part's pose via setPartPose().
+     */
+    virtual int addPart(Trackable* trackable) = 0;
+
+    /// Removes a Trackable from the MultiTarget.
+    /**
+     *  Returns true on success.
+     *  Returns false if the index is invalid or if the corresponding DataSet
+     *  is currently active.
+     */
+    virtual bool removePart(int idx) = 0;
+
+    /// Defines a Part's spatial offset to the MultiTarget center
+    /**
+     *  Per default a new Part has zero offset (no translation, no rotation).
+     *  In this case the pose of the Part is identical with the pose of the
+     *  MultiTarget. If there is more than one Part in a MultiTarget
+     *  then at least one must have an offset, or the Parts are co-located.
+     *  Returns false if the index is invalid or if the corresponding DataSet
+     *  is currently active.
+     */
+    virtual bool setPartOffset(int idx, const Matrix34F& offset) = 0;
+
+    /// Retrieves the spatial offset of a Part to the MultiTarget center
+    /**
+     *  Returns false if the Part's index is invalid.
+     */
+    virtual bool getPartOffset(int idx, Matrix34F& offset) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_MULTITARGET_H_
Index: app/src/main/java/fr/turfu/urbapp2/AugmentedRealityActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AugmentedRealityActivity.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AugmentedRealityActivity.java	(revision )
@@ -0,0 +1,380 @@
+package fr.turfu.urbapp2;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.qualcomm.vuforia.CameraDevice;
+import com.qualcomm.vuforia.DataSet;
+import com.qualcomm.vuforia.HINT;
+import com.qualcomm.vuforia.ImageTargetBuilder;
+import com.qualcomm.vuforia.ObjectTracker;
+import com.qualcomm.vuforia.Renderer;
+import com.qualcomm.vuforia.State;
+import com.qualcomm.vuforia.Trackable;
+import com.qualcomm.vuforia.TrackerManager;
+import com.qualcomm.vuforia.Vec2I;
+import com.qualcomm.vuforia.VideoBackgroundConfig;
+import com.qualcomm.vuforia.VideoMode;
+import com.qualcomm.vuforia.Vuforia;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+
+import fr.turfu.urbapp2.AR.ARRenderer;
+import fr.turfu.urbapp2.AR.ARSurfaceView;
+import fr.turfu.urbapp2.AR.Texture;
+
+/**
+ * Created by Julien Vuillamy on 21/03/16.
+ */
+
+public class AugmentedRealityActivity extends Activity implements Vuforia.UpdateCallbackInterface {
+
+    private final static String LOGTAG = "MainActivity";
+
+    private static boolean isVuforiaInit = false;
+
+    //Integer to give different name to trackers
+    private static int targetBuilderCounter = 0;
+
+    //GLSurfaceView used to render the Augmented Reality with Vuforia
+    private ARSurfaceView ARView;
+
+    //References to UI items
+    private Button buttonStartAR;
+    private Button buttonRotate;
+    private TextView textInstructions;
+
+    //Set used to keep created trackers
+    private DataSet trackerDataset;
+
+    //Used to refresh the dataset when new tracker is created
+    private static boolean targetHasChanged = false;
+
+    //Image Intent result
+    private static final int SELECT_PICTURE = 1;
+    private Bitmap bitmap;
+
+    //AsyncTask to initialize Vuforia
+    private class VuforiaInit extends AsyncTask<Void, Integer, Void> {
+
+        private final static String LOGTAG = "VuforiaInit";
+        private int progress = -1;
+
+        @Override
+        protected Void doInBackground(Void... params) {
+
+            do {
+                progress = Vuforia.init();
+                Log.d(LOGTAG, "Init progress : " + progress);
+                publishProgress(progress);
+            }
+            while (progress >= 0 && progress < 100);
+            return null;
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+
+        Log.d(LOGTAG, " : onCreate");
+        super.onCreate(savedInstanceState);
+
+        //Set activity fullscreen in landscape
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+
+        //Initialize Vuforia if not already done
+        if (!isVuforiaInit) {
+
+            //Vuforia developer licence key
+            Vuforia.setInitParameters(this, Vuforia.GL_20, "Af6cidT/////AAAAAZcuaZYUvUzfrOdxGxxWztBOG1CZpB/j3qoC9FuLlFKcuLnwam5Wd2CvTgj9PTWJ8EdO5l4DGVTZpOVV7y8ZOWsa3GjgcVQVEO163IxAkQYpbV+plZp2oHh76NjMSeeV2I/KMzwF+8DyCkN2d6lK4wELjf9/pfIS+6hJvjw4eYN5YvPKxN7XrAeFwaPVrMQhIgYPq8r9mTvfMXSsr6e7gH9l/hnh/NKcNKn6VdoSiJkcv3ER787/4HOfmJdlimn4YmrG+Q/5CiQM/rAj8utDbQaWyLWJGHmZHFIIzahVqPsxwB/bBNkcjGW/sQQNrJdX663bBqRLAa2Qi8hhlDHR20XbAAprBZJMf5Pk66aWuV7J");
+
+            VuforiaInit vuforiaInit = new VuforiaInit();
+            vuforiaInit.execute();
+            //Waiting for Vuforia to initialize
+            try {
+                vuforiaInit.get();
+            } catch (InterruptedException e) {
+                Log.e(LOGTAG, "Vuforia didn't initialize in time !");
+            } catch (ExecutionException e) {
+                Log.e(LOGTAG, "Error initializing Vuforia !");
+            }
+            Vuforia.registerCallback(this);
+            initTrackers();
+
+            //Initialize the camera
+            int camera = CameraDevice.CAMERA.CAMERA_DEFAULT;
+            start_camera(camera);
+        }
+
+        isVuforiaInit = Vuforia.isInitialized();
+        Vuforia.setHint(HINT.HINT_MAX_SIMULTANEOUS_IMAGE_TARGETS, 5);
+        //Building the Augmented Reality View
+        ARView = new ARSurfaceView(this);
+        ARView.setVisibility(ViewGroup.VISIBLE);
+        setContentView(ARView);
+
+        //Adding the action overlay with validation and image adding buttons
+        RelativeLayout action_overlay = (RelativeLayout) getLayoutInflater().inflate(R.layout.augmented_reality, null);
+        addContentView(action_overlay, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+
+        buttonStartAR = (Button) findViewById(R.id.startAR);
+        buttonRotate = (Button) findViewById(R.id.rotate);
+        buttonStartAR.setVisibility(View.INVISIBLE);
+        buttonRotate.setVisibility(View.INVISIBLE);
+
+        textInstructions = (TextView) findViewById(R.id.textView);
+        textInstructions.setVisibility(View.INVISIBLE);
+    }
+
+    /**
+     * Method called by the submit button from the camera_overlay.xml
+     *
+     * @param view
+     */
+    public void onSubmitButtonClicked(View view) {
+        Log.d(LOGTAG, "SubmitButton clicked");
+        try {
+            String trackerName = buildTracker();
+            ARRenderer.getInstance().setTracked(trackerName);
+        } catch (NullPointerException e) {
+            Log.e(LOGTAG, "Unable to create tracker");
+        }
+    }
+
+    /**
+     * Method called by the rotate button from the camera_overlay.xml
+     *
+     * @param view
+     */
+    public void onRotateButtonClicked(View view) {
+        if (bitmap != null) {
+            Matrix m = new Matrix();
+            m.postRotate(90);
+            bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m, true);
+            Texture t = Texture.loadTexture(bitmap);
+            ARRenderer.getInstance().replaceOverlay(t);
+        }
+    }
+
+    /**
+     * Method called by the add image
+     *
+     * @param view
+     */
+    public void onAddImageButtonClicked(View view) {
+        Intent intent = new Intent();
+        intent.setType("image/*");
+        intent.setAction(Intent.ACTION_GET_CONTENT);
+        startActivityForResult(Intent.createChooser(intent, "Select Picture"), SELECT_PICTURE);
+    }
+
+    /**
+     * Method called when the select image intent is over.
+     *
+     * @param requestCode
+     * @param resultCode
+     * @param data        Data retrieved from the Intent
+     */
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (resultCode == RESULT_OK && requestCode == SELECT_PICTURE) {
+            try {
+                InputStream stream;
+                stream = getContentResolver().openInputStream(data.getData());
+
+                bitmap = BitmapFactory.decodeStream(stream);
+                Texture t = Texture.loadTexture(bitmap);
+                ARRenderer.getInstance().createOverlay(t);
+
+                buttonRotate.setVisibility(View.VISIBLE);
+                buttonStartAR.setVisibility(View.VISIBLE);
+                textInstructions.setVisibility(View.VISIBLE);
+
+                stream.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            } catch (NullPointerException e) {
+                e.printStackTrace();
+            }
+
+
+        }
+
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Override
+    protected void onResume() {
+        Log.d(LOGTAG, ": onResume");
+        super.onResume();
+        Vuforia.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        Log.d(LOGTAG, ": onPause");
+        super.onPause();
+        Vuforia.onPause();
+    }
+
+    /**
+     * Called on every new frame
+     *
+     * @param state
+     */
+    @Override
+    public void QCAR_onUpdate(State state) {
+        if (targetHasChanged) {
+            TrackerManager trackerManager = TrackerManager.getInstance();
+            ObjectTracker objectTracker = (ObjectTracker) trackerManager
+                    .getTracker(ObjectTracker.getClassType());
+
+            Log.d(LOGTAG, "Attempting to transfer the trackable source to the dataset");
+
+            // Deactivate current dataset
+            objectTracker.deactivateDataSet(objectTracker.getActiveDataSet());
+
+            // Add new trackable source
+            Trackable trackable = trackerDataset
+                    .createTrackable(objectTracker.getImageTargetBuilder().getTrackableSource());
+            // Reactivate current dataset
+            objectTracker.activateDataSet(trackerDataset);
+            trackable.startExtendedTracking();
+            targetHasChanged = false;
+
+        }
+    }
+
+    /**
+     * Initialization of the camera
+     *
+     * @param camera
+     */
+    private void start_camera(int camera) {
+
+        Log.d(LOGTAG, "Camera Initialization");
+
+        //Récupération de la taille de l'écran
+        DisplayMetrics dm = getScreenDimensions();
+        int screenHeight = dm.heightPixels;
+        int screenWidth = dm.widthPixels;
+
+        Log.d(LOGTAG, "Screen size : " + screenHeight + "," + screenWidth + "");
+
+        //Récupération de la caméra
+        CameraDevice cameraDevice = CameraDevice.getInstance();
+        cameraDevice.init(camera);
+        cameraDevice.selectVideoMode(CameraDevice.MODE.MODE_DEFAULT);
+
+
+        //Parametrage de la camera
+        VideoMode vm = cameraDevice.getVideoMode(CameraDevice.CAMERA.CAMERA_DEFAULT);
+        VideoBackgroundConfig config = new VideoBackgroundConfig();
+        config.setEnabled(true);
+        config.setPosition(new Vec2I(0, 0));
+
+        int xSize, ySize;
+
+        xSize = screenWidth;
+        ySize = (int) (vm.getHeight() * (screenWidth / (float) vm
+                .getWidth()));
+
+        if (ySize < screenHeight) {
+            xSize = (int) (screenHeight * (vm.getWidth() / (float) vm
+                    .getHeight()));
+            ySize = screenHeight;
+        }
+
+        Log.d(LOGTAG, "Camera size : " + xSize + "," + ySize);
+        config.setSize(new Vec2I(xSize, ySize));
+
+        Renderer.getInstance().setVideoBackgroundConfig(config);
+
+        cameraDevice.start();
+
+        cameraDevice.setFocusMode(CameraDevice.FOCUS_MODE.FOCUS_MODE_CONTINUOUSAUTO);
+
+        isVuforiaInit = true;
+
+    }
+
+    private DisplayMetrics getScreenDimensions() {
+        // Query display dimensions:
+        DisplayMetrics metrics = new DisplayMetrics();
+        getWindowManager().getDefaultDisplay().getMetrics(metrics);
+        return metrics;
+    }
+
+    /**
+     * Build a new tracker and triggers the reload of the database in QCAR_onUpdate
+     *
+     * @return Name given to the tracker
+     */
+    public String buildTracker() {
+
+        TrackerManager trackerManager = TrackerManager.getInstance();
+        ObjectTracker objectTracker = (ObjectTracker) trackerManager.getTracker(ObjectTracker.getClassType());
+
+        if (objectTracker != null) {
+            ImageTargetBuilder targetBuilder = objectTracker.getImageTargetBuilder();
+            if (targetBuilder != null) {
+                objectTracker.stop();
+                Log.d(LOGTAG, "Image quality :" + targetBuilder.getFrameQuality());
+                String name;
+
+                do {
+                    name = "UserTarget-" + targetBuilderCounter;
+                    targetBuilderCounter++;
+                } while (!targetBuilder.build(name, 320.f));
+
+                targetHasChanged = true;
+                objectTracker.start();
+                return name;
+            } else {
+                Log.e(LOGTAG, "Could not get ImageTargetBuilder");
+                throw new NullPointerException();
+            }
+        } else {
+            Log.e(LOGTAG, "Could not get ObjectTracker");
+            throw new NullPointerException();
+        }
+    }
+
+    /**
+     * Create a new object tracker and start scanning to build a user-defined tracker
+     */
+    private void initTrackers() {
+
+        Log.d(LOGTAG, ": initAR");
+        TrackerManager trackerManager = TrackerManager.getInstance();
+        ObjectTracker objectTracker = (ObjectTracker) trackerManager.initTracker(ObjectTracker.getClassType());
+
+        if (objectTracker != null) {
+            Log.d(LOGTAG, "ObjectTracker initialized !");
+
+            trackerDataset = objectTracker.createDataSet();
+            ImageTargetBuilder imageTargetBuilder = objectTracker.getImageTargetBuilder();
+            imageTargetBuilder.startScan();
+        } else
+            Log.e(LOGTAG, "ObjectTracker not initialized");
+    }
+
+}
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tracker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tracker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Tracker.h	(revision )
@@ -0,0 +1,53 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Tracker.h
+
+@brief
+    Header file for Tracker class.
+===============================================================================*/
+#ifndef _QCAR_TRACKER_H_
+#define _QCAR_TRACKER_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Type.h>
+
+namespace QCAR
+{
+
+/// Base class for all tracker types.
+/**
+ *  The class exposes generic functionality for starting and stopping a
+ *  given Tracker as well as querying the tracker type.
+ */
+class QCAR_API Tracker : private NonCopyable
+{
+public:
+
+    /// Returns the Tracker class' type
+    static Type getClassType();
+
+    /// Returns the Tracker instance's type
+    virtual Type getType() const = 0;
+
+    /// Checks whether the Tracker instance's type equals or has been
+    /// derived from a give type
+    virtual bool isOfType(Type type) const = 0;
+
+    /// Starts the Tracker
+    virtual bool start() = 0;
+
+    /// Stops the Tracker
+    virtual void stop() = 0;
+
+    virtual ~Tracker() {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TRACKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/DataSet.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/DataSet.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/DataSet.h	(revision )
@@ -0,0 +1,162 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    DataSet.h
+
+@brief
+    Header file for DataSet class.
+===============================================================================*/
+#ifndef _QCAR_DATASET_H_
+#define _QCAR_DATASET_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/System.h>
+#include <QCAR/QCAR.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class Trackable;
+class MultiTarget;
+class TrackableSource;
+
+/// A container of one or more trackables.
+/**
+ *  A dataset may contain multiple ImageTargets and MultiTargets.
+ *  An empty DataSet instance is created using the DataSet factory function
+ *  provided by the ObjectTracker class. The dataset is then loaded given a
+ *  dataset XML and corresponding dataset DAT file. The dataset may be loaded
+ *  from the storage locations defined below. Note that the root filename of the
+ *  dataset DAT file and XML file must be the same. Once loaded the dataset can
+ *  be activated using ObjectTracker::activateDataSet().
+ *  Methods to modify a DataSet must not be called while it is active. The
+ *  DataSet must be deactivated first before reconfiguring it.
+ */
+class QCAR_API DataSet : private NonCopyable
+{
+public:
+    
+    /// Deprecated enum, use QCAR::STORAGE_TYPE instead.
+    /// Types of storage locations for datasets
+    enum STORAGE_TYPE {
+        STORAGE_APP,            ///< Storage private to the application
+        STORAGE_APPRESOURCE,    ///< Storage for assets bundled with the
+                                ///< application
+        STORAGE_ABSOLUTE        ///< Helper type for specifying an absolute path
+    };
+
+
+    /// Checks if the dataset exists at the specified path and storage location
+    /**
+     *  Returns true if both the dataset XML and DAT file exist at the
+     *  given storage location. The relative path to the dataset XML must be
+     *  passed to this function for all storage locations other than
+     *  STORAGE_ABSOLUTE.
+     */
+    static bool exists(const char* path, QCAR::STORAGE_TYPE storageType);
+
+    /// Checks if the dataset exists at the specified path and storage location
+    /**
+     *  Returns true if both the dataset XML and DAT file exist at the
+     *  given storage location. The relative path to the dataset XML must be
+     *  passed to this function for all storage locations other than
+     *  STORAGE_ABSOLUTE.
+     *  
+     *  This version is now deprecated, please use QCAR::STORAGE_TYPE based 
+     *  method instead.
+     */
+    static bool exists(const char* path, STORAGE_TYPE storageType);
+
+    /// Loads the dataset at the specified path and storage location
+    /**
+     *  Returns true if the dataset was loaded successfully. After loading,
+     *  individual Trackables can be accessed using getNumTrackables() and
+     *  getTrackable(). The relative path to the dataset XML must be passed to
+     *  this function for all storage locations other than STORAGE_ABSOLUTE.
+     *  Note that loading a dataset may take significant time and therefore
+     *  it is recommended to load datasets in the background.
+     *
+     *  This version is now deprecated, please use QCAR::STORAGE_TYPE based 
+     *  method instead.
+     */
+    virtual bool load(const char* path, STORAGE_TYPE storageType) = 0;
+
+    /// Loads the dataset at the specified path and storage location
+    /**
+     *  Returns true if the dataset was loaded successfully. After loading,
+     *  individual Trackables can be accessed using getNumTrackables() and
+     *  getTrackable(). The relative path to the dataset XML must be passed to
+     *  this function for all storage locations other than STORAGE_ABSOLUTE.
+     *  Note that loading a dataset may take significant time and therefore
+     *  it is recommended to load datasets in the background.
+     */
+    virtual bool load(const char* path, QCAR::STORAGE_TYPE storageType) = 0;
+
+    /// Returns the overall number of 3D trackable objects in this data set.
+    /**
+     *  Trackables that are part of other trackables (e.g. an ImageTarget that
+     *  is part of a MultiTarget) is not counted here and not delivered
+     *  by DataSet::getTrackable().
+     */
+    virtual int getNumTrackables() const = 0;
+    
+    /// Returns a pointer to a trackable object.
+    /**
+     *  Trackables that are part of other trackables (e.g. an ImageTarget that
+     *  is part of a MultiTarget) is not delivered by this method.
+     *  Such trackables can be accesses via the trackable they are part of.
+     *  E.g. use MultiTarget::getPart() to access the respective ImageTargets.
+     */
+    virtual Trackable* getTrackable(int idx) = 0;
+
+    /// Creates a new Trackable from the given TrackableSource and registers
+    /// it with the dataset
+    /**
+     *  Use DataSet::destroy() to destroy the returned Trackable
+     *  if it is no longer required.
+     *  This method must not be called while the dataset is active or it will
+     *  return NULL.
+     */
+    virtual Trackable* createTrackable(const TrackableSource* source) = 0;
+
+    /// Creates a new MultiTarget and registers it with the dataset
+    /**
+     *  Use DataSet::destroy() to destroy the returned MultiTarget
+     *  if it is no longer required.
+     *  This method must not be called while the dataset is active or it will
+     *  return NULL.
+     */
+    virtual MultiTarget* createMultiTarget(const char* name) = 0;
+
+    /// Destroys a Trackable
+    /**
+     *  This method must not be called while the dataset is active or it will
+     *  return false.
+     */
+    virtual bool destroy(Trackable* trackable) = 0;
+
+    /// Checks if this DataSet's Trackable capacity is reached.
+    /**
+     *  Returns true if the number of Trackables created in this DataSet
+     *  has reached the maximum capacity, false otherwise.
+     */
+    virtual bool hasReachedTrackableLimit() = 0;
+
+    /// Checks if this dataset is active
+    /**
+     * Returns true if the dataset is active
+     */
+    virtual bool isActive() const = 0;
+
+    virtual ~DataSet()  {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_DATASET_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/GLOverlay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/GLOverlay.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/GLOverlay.java	(revision )
@@ -0,0 +1,379 @@
+package fr.turfu.urbapp2.AR;
+
+import android.opengl.GLES20;
+import android.opengl.Matrix;
+import android.util.Log;
+
+import com.qualcomm.vuforia.Vec4F;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+/**
+ * Created by Julien Vuillamy on 08/03/16.
+ *
+ * This class implements the GL rendering of a texture using Vuforia's tracker data.
+ */
+
+public class GLOverlay {
+
+    private final static String LOGTAG = "GLOverlay";
+
+    //Classes to identify Shader of Program loading problems
+    public final static class GLShaderException extends Exception {
+        public GLShaderException(String message) {
+            super(message);
+        }
+    }
+    public final static class GLProgramException extends Exception {
+        public GLProgramException(String message) {
+            super(message);
+        }
+    }
+
+    private final static int BYTES_PER_FLOAT = 4 ;
+
+    //Texture rendered on this view
+    private final Texture texture ;
+
+    //Tracker currently tracking this view
+    private String trackerName ;
+
+    //Vertices, texture coordinates and vector
+    private float frameVertices[];
+    private float frameTexCoords[];
+
+    //Vector controling the transparency of an instance
+    private Vec4F transColor ;
+
+    //Program handle
+    private int programHandle;
+
+    //GL Attribute handles
+    private int vertexHandle ;
+    private int textureCoordHandle ;
+    private int mvpMatrixHandle ;
+    private int texSampler2DHandle;
+    private int colorHandle;
+
+    private boolean isTracked ;
+    private boolean isInit ;
+
+    //GLOverlay resize/reshaping values
+    private float shearV = 0f ;
+    private float shearH = 0f;
+    private float scale = 0.1f ;
+
+    public GLOverlay(Texture t) {
+        texture = t;
+        transColor = new Vec4F();
+        isInit = false ;
+
+        //A new GLOverlay is initialized as not tracked
+        isTracked = false ;
+    }
+
+    /**
+     * Creates the GL Vertices according to the user transformations
+     */
+    public void createObjectVertices () {
+        frameVertices = new float[] {
+                -texture.mWidth *scale,  texture.mHeight*scale, 100.0f+shearH+shearV,
+                -texture.mWidth *scale, - texture.mHeight *scale, 100.0f-shearH+shearV,
+                texture.mWidth *scale,  texture.mHeight *scale, 100.0f+shearH-shearV,
+
+                -texture.mWidth *scale,- texture.mHeight *scale,100.0f-shearH+shearV,
+                texture.mWidth *scale,- texture.mHeight *scale,100.0f-shearH-shearV,
+                texture.mWidth*scale,  texture.mHeight *scale,100.0f+shearH-shearV
+        };
+    }
+
+    /**
+     * Initializes the view by creating the GL bindings, loading textures and creating the GL program
+     * @return True if correctly initialized
+     */
+    public boolean init() {
+
+        if (isInit)
+            return true ;
+
+        //Loading texture
+        GLES20.glGenTextures(1, texture.mTextureID, 0);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture.mTextureID[0]);
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_TEXTURE_2D);
+        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA,
+                texture.mWidth, texture.mHeight, 0, GLES20.GL_RGBA,
+                GLES20.GL_UNSIGNED_BYTE, texture.mData);
+
+        try {
+            //Load shaders
+            final int vertexShaderHandle = loadShader(GLES20.GL_VERTEX_SHADER, getVertexShader());
+            final int fragmentShaderHandle = loadShader(GLES20.GL_FRAGMENT_SHADER, getFragmentShader());
+
+            //Create program
+            programHandle = createProgram(vertexShaderHandle, fragmentShaderHandle);
+        }
+        catch (GLShaderException e) {
+            Log.e(LOGTAG, e.getMessage());
+            return false ;
+        }
+        catch (GLProgramException e) {
+            Log.e(LOGTAG, e.getMessage());
+            return false ;
+        }
+
+        //Getting handles from program
+        vertexHandle = GLES20.glGetAttribLocation(programHandle, "vertexPosition");
+        textureCoordHandle = GLES20.glGetAttribLocation(programHandle, "vertexTexCoord");
+        colorHandle = GLES20.glGetUniformLocation(programHandle, "colorKey");
+        mvpMatrixHandle = GLES20.glGetUniformLocation(programHandle, "modelViewProjectionMatrix");
+        texSampler2DHandle = GLES20.glGetUniformLocation(programHandle, "texSampler2D");
+
+
+
+        if (vertexHandle == -1 || textureCoordHandle == -1
+                || mvpMatrixHandle == -1)
+            return false ;
+
+
+
+
+        //Create vertices,textures coordinates and vector indices
+        createObjectVertices();
+
+        frameTexCoords = new float[] {
+                0.0f, 1.0f,
+                0.0f,0.0f,
+                1.0f,1.0f,
+
+                0.0f,0.0f,
+                1.0f, 0.0f,
+                1.0f, 1.0f
+        };
+
+        float[] tempColor = new float[] {1.0f,1.0f,1.0f,0.7f};
+        transColor.setData(tempColor);
+
+//        //Set GL Flags
+
+        isInit = true ;
+        return true ;
+    }
+
+    /**
+     * Called on every frame, renders the view in the middle of the screen if the overlay is not tracked,
+     * renders using the Vuforia modelView matrix to correctly position the overlay otherwise
+     */
+    public void render() {
+
+        if (!isInit)
+            isInit = init();
+
+//      Calculated the Model-View-Projection matrix
+        float[] mvpMatrix = new float[16];
+
+        float[] projectionMatrix = ARRenderer.getInstance().getProjection();
+        float[] modelViewMatrix = ARRenderer.getInstance().getModelView(isTracked);
+
+        //Extra precaution : in case the modelViewMatrix is null, abort rendering
+        if (modelViewMatrix == null)
+            return ;
+
+        Matrix.multiplyMM(mvpMatrix, 0, projectionMatrix, 0, modelViewMatrix, 0);
+
+
+        //Set GL Flags
+        GLES20.glFrontFace(GLES20.GL_CCW);
+        GLES20.glDisable(GLES20.GL_DEPTH_TEST);
+        GLES20.glDisable(GLES20.GL_CULL_FACE);
+        GLES20.glEnable(GLES20.GL_BLEND);
+        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA);
+
+        //Set the shader program
+        GLES20.glUseProgram(programHandle);
+
+        //Set the vertex handle
+        FloatBuffer verticesBuffer = ByteBuffer.allocateDirect(frameVertices.length * BYTES_PER_FLOAT)
+                .order(ByteOrder.nativeOrder()).asFloatBuffer();
+        verticesBuffer.put(frameVertices).position(0);
+        GLES20.glVertexAttribPointer(vertexHandle, 3, GLES20.GL_FLOAT, false, 0, verticesBuffer);
+
+        //Set the texture coordinate handle
+        FloatBuffer texCoordBuffer = ByteBuffer.allocateDirect(frameTexCoords.length * BYTES_PER_FLOAT)
+                .order(ByteOrder.nativeOrder()).asFloatBuffer();
+        texCoordBuffer.put(frameTexCoords).position(0);
+        GLES20.glVertexAttribPointer(textureCoordHandle, 2, GLES20.GL_FLOAT, false, 0, texCoordBuffer);
+
+        GLES20.glEnableVertexAttribArray(vertexHandle);
+        GLES20.glEnableVertexAttribArray(textureCoordHandle);
+
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,
+                texture.mTextureID[0]);
+
+        //Set the ModelViewProjection matrix to the mvpHandle
+
+        GLES20.glUniformMatrix4fv(mvpMatrixHandle, 1, false, mvpMatrix, 0);
+
+        GLES20.glUniform1i(texSampler2DHandle, 0);
+
+        GLES20.glUniform4fv(colorHandle, 1, transColor.getData(), 0);
+
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES,0,6);
+
+        GLES20.glDisableVertexAttribArray(vertexHandle);
+        GLES20.glDisableVertexAttribArray(textureCoordHandle);
+
+        GLES20.glDisable(GLES20.GL_BLEND);
+        GLES20.glEnable(GLES20.GL_DEPTH_TEST);
+
+    }
+
+    /**
+     * Method to create the vertexShader String
+     * @return Vertex Shader
+     */
+    private String getVertexShader() {
+        return  "attribute vec4 vertexPosition ; \n" +
+                "attribute vec2 vertexTexCoord; \n" +
+                "varying vec2 texCoord; \n" +
+                "uniform mat4 modelViewProjectionMatrix; \n" +
+                "void main() \n" +
+                "{ \n" +
+                "   gl_Position = modelViewProjectionMatrix * vertexPosition; \n" +
+                "   texCoord= vertexTexCoord; \n" +
+                "} \n";
+    }
+
+    /**
+     * Method to create the fragmentShader String
+     * @return Framgment Shader
+     */
+    private String getFragmentShader () {
+        return  "precision mediump float ; \n" +
+                "varying vec2 texCoord; \n" +
+                "uniform vec4 colorKey; \n" +
+                "uniform sampler2D texSampler2D; \n" +
+                "void main() \n" +
+                "{ \n" +
+                "   vec4 texColor = texture2D(texSampler2D, texCoord); \n" +
+                "   gl_FragColor = colorKey * texColor; \n" +
+                "} \n" ;
+    }
+
+    /**
+     * Creates a GL Shader according to its type and source and returns a shaderHandle
+     * @param shaderType VertexShader or FragmentShader
+     * @param shaderSource Shader string corresponding to the shaderType
+     * @return Created ShaderHandle
+     * @throws GLShaderException
+     */
+    private int loadShader(int shaderType, String shaderSource)
+            throws GLShaderException {
+
+        int shaderHandle ;
+
+        shaderHandle = GLES20.glCreateShader(shaderType);
+        if (shaderHandle != 0) {
+            GLES20.glShaderSource(shaderHandle, shaderSource);
+            GLES20.glCompileShader(shaderHandle);
+            final int[] compileStatus = new int[1];
+            GLES20.glGetShaderiv(shaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
+            if (compileStatus[0] == 0) {
+                String error = GLES20.glGetShaderInfoLog(shaderHandle);
+                GLES20.glDeleteShader(shaderHandle);
+
+                throw new GLShaderException("Error compiling shader : " + error);
+            }
+        } else
+            throw new GLShaderException("Error creating shader");
+
+        return shaderHandle;
+    }
+
+    /**
+     * Binds a vertexShader and a fragmentShader into a GL programHandle
+     * @param vertexShaderhandle
+     * @param fragmentShaderhandle
+     * @return programHandle
+     * @throws GLProgramException
+     */
+    private int createProgram(int vertexShaderhandle, int fragmentShaderhandle)
+            throws GLProgramException {
+
+        int programHandle = GLES20.glCreateProgram();
+
+        if (programHandle != 0) {
+
+            GLES20.glAttachShader(programHandle, vertexShaderhandle);
+            GLES20.glAttachShader(programHandle, fragmentShaderhandle);
+
+            GLES20.glLinkProgram(programHandle);
+
+            final int[] linkStatus = new int[1];
+            GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0);
+
+            if (linkStatus[0] == 0) {
+                String error = GLES20.glGetProgramInfoLog(programHandle);
+                GLES20.glDeleteProgram(programHandle);
+
+                throw new GLProgramException("Error linking program : " + error);
+            }
+        }
+        else
+            throw new GLProgramException("Error creating program.");
+
+        return programHandle;
+    }
+
+    /**
+     * Setter for boolean isTracked and pass in the tracker name
+     * @param tN Tracker name for this overlay
+     */
+    public void setTracked(String tN)
+    {
+        isTracked = true ;
+        trackerName = tN ;
+    }
+
+    /**
+     * Getter for the boolean isTracked
+     * @return isTracked
+     */
+    public boolean isTracked() { return isTracked;}
+
+    /**
+     * Transforms the overlay according to the TransformType and value
+     * @param t Transformation : SCALE, SHEARH, or SHEARV
+     * @param value value of the transformation
+     */
+    public void transformObject(TransformType t, float value)
+    {
+        switch (t)
+        {
+            case SCALE:
+                scale = (float) Math.max((double) (scale * value), 0.001f);
+                break ;
+            case SHEARH:
+                shearH += value;
+                break ;
+            case SHEARV:
+                shearV +=value;
+                break ;
+        }
+        createObjectVertices();
+    }
+
+    /**
+     * Getter for the tracker name
+     * @return trackerName
+     */
+    public String getTrackerName()
+    {
+        return trackerName;
+    }
+}
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableResult.h	(revision )
@@ -0,0 +1,69 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TrackableResult.h
+
+@brief
+    Header file for TrackableResult class.
+===============================================================================*/
+#ifndef _QCAR_TRACKABLERESULT_H_
+#define _QCAR_TRACKABLERESULT_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/System.h>
+#include <QCAR/Trackable.h>
+
+namespace QCAR
+{
+
+/// Base class for all result objects.
+/**
+ *  A TrackableResult is an object that represents the state of a Trackable
+ *  which was found in a given frame. Every TrackableResult has a corresponding
+ *  Trackable, a type, a 6DOF pose and a status (e.g. tracked).
+ */
+class QCAR_API TrackableResult : private NonCopyable
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the TrackableResult instance's type
+    virtual Type getType() const = 0;
+
+    /// Checks whether the TrackableResult instance's type equals or has been
+    /// derived from a give type
+    virtual bool isOfType(Type type) const = 0;
+
+    /// Status of a TrackableResults
+    enum STATUS {
+        UNKNOWN,            ///< The state of the TrackableResult is unknown
+        UNDEFINED,          ///< The state of the TrackableResult is not defined
+                            ///< (this TrackableResult does not have a state)
+        DETECTED,           ///< The TrackableResult was detected
+        TRACKED,            ///< The TrackableResult was tracked
+        EXTENDED_TRACKED    ///< The Trackable Result was extended tracked
+    };
+
+    /// Returns the tracking status
+    virtual STATUS getStatus() const = 0;
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const Trackable& getTrackable() const = 0;
+
+    /// Returns the current pose matrix in row-major order
+    virtual const Matrix34F& getPose() const = 0;
+
+    virtual ~TrackableResult()  {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TRACKABLERESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Surface.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Surface.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Surface.h	(revision )
@@ -0,0 +1,72 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Surface.h
+
+@brief
+    Header file for Surface class.
+===============================================================================*/
+#ifndef _QCAR_SURFACE_H_
+#define _QCAR_SURFACE_H_
+
+// Include files
+#include <QCAR/SmartTerrainTrackable.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class Rectangle;
+class Mesh;
+
+/// A trackable representing a dynamically expanding terrain with objects on top.
+/**
+ * The Surface class provides access to all data of the reconstructed ground
+ * plane. It inherits from SmartTerrainTrackable where the Mesh represents the
+ * overall extents of the ground plane. In addition a NavMesh represents the
+ * navigable portion of that mesh with objects cut out.
+ */
+class QCAR_API Surface : public SmartTerrainTrackable
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+    
+    /// Returns the navigation mesh where the mesh boundary has been padded
+    /**
+     *  The mesh will change over time.
+     */
+    virtual const Mesh* getNavMesh() const = 0;
+
+    /// Returns the axis-aligned bounding box of the ground mesh
+    /**
+     *  The bounding box will change over time.
+     */
+    virtual const Rectangle& getBoundingBox() const = 0;  
+
+    /// Returns the number of indices for ground mesh boundaries
+    /**
+     *  Each consecutive pair of indices defines a line segment. As a whole this
+     *  defines a polygon that represents the outer extents of the Surface mesh.
+     *  The mesh boundaries will change over time.
+     */
+    virtual int getNumMeshBoundaries() const = 0;
+
+    /// Returns the line list that represents all boundaries.
+    /** 
+     *  Each consecutive pair of indices defines a line segment. As a whole this
+     *  defines a polygon that represents the outer extents of the Surface mesh.
+     *  The indices refer to points in the mesh.
+     */
+    virtual const unsigned short* getMeshBoundaries() const = 0;
+    
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_SURFACE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/UpdateCallback.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/UpdateCallback.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/UpdateCallback.h	(revision )
@@ -0,0 +1,35 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    UpdateCallback.h
+
+@brief
+    Header file for UpdateCallback class.
+===============================================================================*/
+#ifndef _QCAR_UPDATECALLBACK_H_
+#define _QCAR_UPDATECALLBACK_H_
+
+// Include files
+#include <QCAR/System.h>
+
+namespace QCAR
+{
+
+// Forward declarations
+class State;
+
+/// UpdateCallback interface
+class QCAR_API UpdateCallback
+{
+public:
+    /// Called by the SDK right after tracking finishes
+    virtual void QCAR_onUpdate(State& state) = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_UPDATECALLBACK_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTarget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTarget.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ImageTarget.h	(revision )
@@ -0,0 +1,84 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ImageTarget.h
+
+@brief
+    Header file for ImageTarget class.
+===============================================================================*/
+#ifndef _QCAR_IMAGETARGET_H_
+#define _QCAR_IMAGETARGET_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+#include <QCAR/ObjectTarget.h>
+#include <QCAR/Vectors.h>
+
+
+namespace QCAR
+{
+
+// Forward declarations
+class Area;
+class VirtualButton;
+
+/// A flat natural feature target
+/**
+ *  Methods to modify an ImageTarget must not be called while the
+ *  corresponding DataSet is active. The dataset must be deactivated first
+ *  before reconfiguring an ImageTarget.
+ */
+class QCAR_API ImageTarget : public ObjectTarget
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the number of virtual buttons defined for this ImageTarget.
+    virtual int getNumVirtualButtons() const = 0;
+
+    /// Provides write access to a specific virtual button.
+    virtual VirtualButton* getVirtualButton(int idx) = 0;
+
+    /// Provides read-only access to a specific virtual button.
+    virtual const VirtualButton* getVirtualButton(int idx) const = 0;
+
+    /// Returns a virtual button by its name
+    /**
+     *  Returns NULL if no virtual button with that name
+     *  exists in this ImageTarget
+     */
+    virtual VirtualButton* getVirtualButton(const char* name) = 0;
+
+    /// Returns a virtual button by its name
+    /**
+     *  Returns NULL if no virtual button with that name
+     *  exists in this ImageTarget
+     */
+    virtual const VirtualButton* getVirtualButton(const char* name) const = 0;
+
+    /// Creates a new virtual button and adds it to the ImageTarget
+    /**
+     *  Returns NULL if the corresponding DataSet is currently active.
+     */
+    virtual VirtualButton* createVirtualButton(const char* name, const Area& area) = 0;
+
+    /// Removes and destroys one of the ImageTarget's virtual buttons
+    /**
+     *  Returns false if the corresponding DataSet is currently active.
+     */
+    virtual bool destroyVirtualButton(VirtualButton* button) = 0;
+
+    /// Returns the meta data string for this ImageTarget.
+    virtual const char* getMetaData() const = 0;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_IMAGETARGET_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb2D.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb2D.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb2D.h	(revision )
@@ -0,0 +1,59 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Obb2d.h
+
+@brief
+    Header file for Obb2d class.
+===============================================================================*/
+#ifndef _QCAR_OBB2D_H_
+#define _QCAR_OBB2D_H_
+
+#include <QCAR/QCAR.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+/// An Obb2D represents a 2D oriented bounding box
+class QCAR_API Obb2D
+{
+public:
+
+    /// Constructor.
+    Obb2D();
+
+    /// Copy constructor.
+    Obb2D(const Obb2D& other);
+
+    /// Construct from center, half extents and rotation.
+    Obb2D(const Vec2F& nCenter, const Vec2F& nHalfExtents,
+        float nRotation);
+
+    /// Returns the center of the bounding box.
+    virtual const Vec2F& getCenter() const;
+
+    /// Returns the half width and half height of the bounding box.
+    virtual const Vec2F& getHalfExtents() const;
+
+    /// Returns the counter-clock-wise rotation angle (in radians) 
+    /// of the bounding box with respect to the X axis.
+    virtual float getRotation() const;
+
+    virtual ~Obb2D();
+
+protected:
+    Vec2F center;
+    Vec2F halfExtents;
+    float rotation;
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_OBB2D_H_
Index: app/src/main/res/values-fr/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values-fr/strings.xml	(revision )
+++ app/src/main/res/values-fr/strings.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!-- Resources for Augmented Reality activity-->
+    <string name="ar_add_image">Ajouter une image</string>
+    <string name="ar_instruction">Zoomer afin d\'ajuster l\'image</string>
+    <string name="ar_rotate">Pivoter</string>
+    <string name="ar_validation">Activer</string>
+</resources>
\ No newline at end of file
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Area.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Area.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Area.h	(revision )
@@ -0,0 +1,43 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Area.h
+
+@brief
+    Header file for Area class.
+===============================================================================*/
+
+#ifndef _QCAR_AREA_H_
+#define _QCAR_AREA_H_
+
+#include <QCAR/QCAR.h>
+
+namespace QCAR
+{
+
+/// Area is the base class for 2D shapes used in Vuforia
+class QCAR_API Area
+{
+public:
+    enum TYPE {
+        RECTANGLE,
+        RECTANGLE_INT,
+        INVALID
+    };
+
+    virtual TYPE getType() const = 0;
+
+    virtual ~Area();
+
+private:
+    Area& operator=(const Area& other);
+};
+
+} // namespace QCAR
+
+
+#endif // _QCAR_AREA_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/QCAR.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/QCAR.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/QCAR.h	(revision )
@@ -0,0 +1,179 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    QCAR.h
+
+@brief
+    Header file for global QCAR methods.
+===============================================================================*/
+#ifndef _QCAR_QCAR_H_
+#define _QCAR_QCAR_H_
+
+// Include files
+#include <QCAR/System.h>
+
+namespace QCAR
+{
+
+// Forward declarations
+class UpdateCallback;
+class VideoSource;
+
+/// Initialization flags
+/**
+ *  Use when calling init()
+ */
+enum INIT_FLAGS {
+    GL_11 = 1,          ///< Enables OpenGL ES 1.1 rendering
+    GL_20 = 2           ///< Enables OpenGL ES 2.0 rendering
+};
+
+/// Return codes for init() function
+enum {
+    INIT_ERROR = -1,                                ///< Error during initialization
+    INIT_DEVICE_NOT_SUPPORTED = -2,                 ///< The device is not supported
+    INIT_NO_CAMERA_ACCESS = -3,                     ///< Cannot access the camera
+    INIT_LICENSE_ERROR_MISSING_KEY = -4,            ///< License key is missing
+    INIT_LICENSE_ERROR_INVALID_KEY = -5,            ///< Invalid license key passed to SDK
+    INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT = -6,   ///< Unable to verify license key due to network (Permanent error)
+    INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT = -7,   ///< Unable to verify license key due to network (Transient error)
+    INIT_LICENSE_ERROR_CANCELED_KEY = -8,           ///< Provided key is no longer valid
+    INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH = -9,  ///< Provided key is not valid for this product
+    INIT_EXTERNAL_DEVICE_NOT_DETECTED = -10         ///< Dependent external device not detected/plugged in
+};
+
+
+/// Pixel encoding types
+enum PIXEL_FORMAT {
+    UNKNOWN_FORMAT = 0,         ///< Unknown format - default pixel type for
+                                ///< undefined images
+    RGB565 = 1,                 ///< A color pixel stored in 2 bytes using 5
+                                ///< bits for red, 6 bits for green and 5 bits
+                                ///< for blue
+    RGB888 = 2,                 ///< A color pixel stored in 3 bytes using
+                                ///< 8 bits each
+    GRAYSCALE = 4,              ///< A grayscale pixel stored in one byte
+    YUV = 8,                    ///< A color pixel stored in 12 or more bits
+                                ///< using Y, U and V planes
+    RGBA8888 = 16,              ///< A color pixel stored in 32 bits using 8 bits
+                                ///< each and an alpha channel.
+    INDEXED = 32,               ///< One byte per pixel where the value maps to
+                                ///< a domain-specific range.
+};
+
+
+/// Use when calling setHint()
+enum HINT {
+    /// How many image targets to detect and track at the same time
+    /**
+     *  This hint tells the tracker how many image shall be processed
+     *  at most at the same time. E.g. if an app will never require
+     *  tracking more than two targets, this value should be set to 2.
+     *  Default is: 1.
+     */
+    HINT_MAX_SIMULTANEOUS_IMAGE_TARGETS = 0,
+
+    /// How many object targets to detect and track at the same time
+    /**
+    *  This hint tells the tracker how many 3D objects shall be processed
+    *  at most at the same time. E.g. if an app will never require
+    *  tracking more than 1 target, this value should be set to 1.
+    *  Default is: 1.
+    */
+    HINT_MAX_SIMULTANEOUS_OBJECT_TARGETS = 1,
+
+    /// Force delayed loading for object target Dataset
+    /**
+    *  This hint tells the tracker to enable/disable delayed loading 
+    *  of object target datasets upon first detection. 
+    *  Loading time of large object dataset will be reduced 
+    *  but the initial detection time of targets will increase.
+    *  Please note that the hint should be set before loading 
+    *  any object target dataset to be effective.
+    *  To enable delayed loading set the hint value to 1.
+    *  To disable delayed loading set the hint value to 0.
+    *  Default is: 0.
+    */
+    HINT_DELAYED_LOADING_OBJECT_DATASETS = 2,
+};
+
+/// Types of storage locations for datasets
+enum STORAGE_TYPE {
+    STORAGE_APP,            ///< Storage private to the application
+    STORAGE_APPRESOURCE,    ///< Storage for assets bundled with the
+                            ///< application
+    STORAGE_ABSOLUTE        ///< Helper type for specifying an absolute path
+};
+
+
+/// Deinitializes Vuforia
+void QCAR_API deinit();
+
+
+/// Sets a hint for the Vuforia SDK
+/**
+ *  Hints help the SDK to understand the developer's needs.
+ *  However, depending on the device or SDK version the hints
+ *  might not be taken into consideration.
+ *  Returns false if the hint is unknown or deprecated.
+ *  For a boolean value 1 means true and 0 means false.
+ */
+bool QCAR_API setHint(unsigned int hint, int value);
+
+
+/// Registers an object to be called when new tracking data is available
+void QCAR_API registerCallback(UpdateCallback* object);
+
+
+/// Enables the delivery of certain pixel formats via the State object
+/**
+ *  Per default the state object will only contain images in formats
+ *  that are required for internal processing, such as gray scale for
+ *  tracking. setFrameFormat() can be used to enforce the creation of
+ *  images with certain pixel formats. Notice that this might include
+ *  additional overhead.
+ */
+bool QCAR_API setFrameFormat(PIXEL_FORMAT format, bool enabled);
+
+
+/// Returns the number of bits used to store a single pixel of a given format
+/**
+ *  Returns 0 if the format is unknown.
+ */
+int QCAR_API getBitsPerPixel(PIXEL_FORMAT format);
+
+
+/// Indicates whether the rendering surface needs to support an alpha channel
+/// for transparency
+bool QCAR_API requiresAlpha();
+
+
+/// Returns the number of bytes for a buffer with a given size and format
+/**
+ *  Returns 0 if the format is unknown.
+ */
+int QCAR_API getBufferSize(int width, int height, PIXEL_FORMAT format);
+
+
+/// Executes AR-specific tasks upon the onResume activity event
+void QCAR_API onResume();
+
+
+/// Executes AR-specific tasks upon the onResume activity event
+void QCAR_API onPause();
+
+
+/// Executes AR-specific tasks upon the onSurfaceCreated render surface event
+void QCAR_API onSurfaceCreated();
+
+
+/// Executes AR-specific tasks upon the onSurfaceChanged render surface event
+void QCAR_API onSurfaceChanged(int width, int height);
+
+} // namespace QCAR
+
+#endif //_QCAR_QCAR_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTracker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTracker.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTracker.h	(revision )
@@ -0,0 +1,53 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    SmartTerrainTracker.h
+
+@brief
+    Header file for SmartTerrainTracker class.
+===============================================================================*/
+#ifndef _QCAR_SMARTTERRAINTRACKER_H_
+#define _QCAR_SMARTTERRAINTRACKER_H_
+
+#include <QCAR/QCAR.h>
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Trackable.h>
+#include <QCAR/SmartTerrainBuilder.h>
+#include <QCAR/SmartTerrainTrackable.h>
+
+namespace QCAR
+{
+
+/// 
+class QCAR_API SmartTerrainTracker : public Tracker
+{
+public:
+
+    /// Returns the tracker class' type
+    static Type getClassType();
+    
+    /// Set the scaling factor for SmartTerrain trackables from millimeters 
+    /// into scene units.
+    /* 
+     * The default scaling factor is 1.0.
+     * Returns false if the tracker is not in the stopped state, true if the 
+     * scale is non-zero and we are able to set the scale factor.
+     */
+    virtual bool setScaleToMillimeter(float scaleFactor) =0;
+
+    /// Gets the scaling factor from millimeters to scene units.
+    virtual float getScaleToMillimeter() const = 0;
+
+    /// Gets a reference to the SmartTerrainBuilder.
+    virtual SmartTerrainBuilder& getSmartTerrainBuilder() = 0;
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_SMARTTERRAINTRACKER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Trackable.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Trackable.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Trackable.h	(revision )
@@ -0,0 +1,69 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Trackable.h
+
+@brief
+    Header file for Trackable class.
+===============================================================================*/
+#ifndef _QCAR_TRACKABLE_H_
+#define _QCAR_TRACKABLE_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/System.h>
+#include <QCAR/Type.h>
+
+namespace QCAR
+{
+
+/// Base class for all objects that can be tracked.
+/**
+ *  Every Trackable has a name, an id and a type.
+ */
+class QCAR_API Trackable : private NonCopyable
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the Trackable instance's type
+    virtual Type getType() const = 0;
+
+    /// Checks whether the Trackable instance's type equals or has been
+    /// derived from a give type
+    virtual bool isOfType(Type type) const = 0;
+        
+    /// Returns a unique id for all 3D trackable objects
+    virtual int getId() const = 0;
+
+    /// Returns the Trackable's name
+    virtual const char* getName() const = 0;
+
+    /// Sets the given user data for this Trackable. Returns true if successful
+    virtual bool setUserData(void* userData) = 0;
+
+    /// Returns the pointer previously set by setUserData()
+    virtual void* getUserData() const = 0;
+
+    /// Starts extended tracking for this Trackable. Returns true if successful
+    virtual bool startExtendedTracking() = 0;
+
+    /// Stops extended tracking for this Trackable. Returns true if successful
+    virtual bool stopExtendedTracking() = 0;
+
+    /// Returns true if extended tracking has been enabled, false otherwise.
+    virtual bool isExtendedTrackingStarted() const = 0;
+
+    virtual ~Trackable()  {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TRACKABLE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/System.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/System.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/System.h	(revision )
@@ -0,0 +1,66 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    System.h
+
+@brief
+    System specific definitions.
+===============================================================================*/
+#ifndef _QCAR_SYSTEM_H_
+#define _QCAR_SYSTEM_H_
+
+// Include files
+#if defined(_WIN32_WCE) || defined(WIN32)
+#  define QCAR_IS_WINDOWS
+#endif
+
+
+// Define exporting/importing of methods from module
+//
+#ifdef QCAR_IS_WINDOWS
+
+#  ifdef QCAR_EXPORTS
+#    define QCAR_API __declspec(dllexport)
+#  elif defined(QCAR_STATIC)
+#    define QCAR_API
+#  else
+#    define QCAR_API __declspec(dllimport)
+#  endif
+
+#else // !QCAR_IS_WINDOWS
+
+#  ifdef QCAR_EXPORTS
+#    define QCAR_API __attribute__((visibility("default"))) 
+#  elif defined(QCAR_STATIC)
+#    define QCAR_API
+#  else
+#    define QCAR_API __attribute__((visibility("default")))
+#  endif
+
+#endif
+
+
+// Platform defines
+#ifdef QCAR_IS_WINDOWS
+
+namespace QCAR
+{
+    typedef unsigned __int16 UInt16;
+}
+
+#else // !QCAR_IS_WINDOWS
+
+#include <stdio.h> 
+
+namespace QCAR
+{
+    typedef __uint16_t UInt16;
+}
+
+#endif
+
+#endif // _QCAR_SYSTEM_H_
Index: app/src/main/res/layout/augmented_reality.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/augmented_reality.xml	(revision )
+++ app/src/main/res/layout/augmented_reality.xml	(revision )
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+
+
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_centerInParent="true"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    tools:context="com.prod.jvuil.arimage.MainActivity"
+    android:id="@+id/camera_overlay_layout">
+
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAppearance="?android:attr/textAppearanceLarge"
+        android:text="@string/ar_instruction"
+        android:id="@+id/textView"
+        android:textColor="#ffffff"
+        android:textSize="30dp"
+        android:textStyle="bold"
+        android:layout_alignParentTop="true"
+        android:layout_centerHorizontal="true" />
+
+    <Button
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/ar_validation"
+        android:id="@+id/startAR"
+        android:onClick="onSubmitButtonClicked"
+        android:layout_alignParentBottom="true"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentEnd="true" />
+
+    <Button
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/ar_add_image"
+        android:id="@+id/add_image"
+        android:layout_alignParentBottom="true"
+        android:layout_centerHorizontal="true"
+        android:onClick="onAddImageButtonClicked"/>
+
+    <Button
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/ar_rotate"
+        android:id="@+id/rotate"
+        android:onClick="onRotateButtonClicked"
+        android:layout_alignParentBottom="true"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true" />
+
+
+</RelativeLayout>
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Image.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Image.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Image.h	(revision )
@@ -0,0 +1,90 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Image.h
+
+@brief
+    Header file for Image class.
+===============================================================================*/
+#ifndef _QCAR_IMAGE_H_
+#define _QCAR_IMAGE_H_
+
+// Include files
+#include <QCAR/QCAR.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+/// An image as e.g. returned by the CameraDevice object
+/**
+ *  The image's pixel buffer can have a different size than the
+ *  getWidth() and getHeight() methods report. This is e.g. the
+ *  case when an image is used for rendering as a texture without
+ *  non-power-of-two support.
+ *  The real size of the image's pixel buffer can be queried using
+ *  getBufferWidth() and getBufferHeight(). 
+ */
+class QCAR_API Image : private NonCopyable
+{
+public:
+    /// Returns the width of the image in pixels
+    /**
+     *  getWidth() returns the number of pixels in the pixel buffer that make up
+     *  the used image area. The pixel buffer can be wider than this. Use
+     *  getBufferWidth() to find out the real width of the pixel buffer.
+     */
+    virtual int getWidth() const = 0;
+
+    /// Returns the height of the image in pixels
+    /**
+     *  getHeight() returns the number of pixel rows in the pixel buffer that
+     *  make up the used image area. The pixel buffer can have more rows than
+     *  that. Use getBufferHeight() to find out the real number of rows that fit
+     *  into the buffer.
+     */
+    virtual int getHeight() const = 0;
+
+    /// Returns the number bytes from one row of pixels to the next row
+    /**
+     *  Per default the stride is number-of-pixels times bytes-per-pixel.
+     *  However, in some cases there can be additional padding bytes at
+     *  the end of a row (e.g. to support power-of-two textures).
+     */
+    virtual int getStride() const = 0;
+
+    /// Returns the number of pixel columns that fit into the pixel buffer
+    /**
+     *  Per default the number of columns that fit into the pixel buffer
+     *  is identical to the width of the image.
+     *  However, in some cases there can be additional padding columns at
+     *  the right side of an image (e.g. to support power-of-two textures).
+     */
+    virtual int getBufferWidth() const = 0;
+
+    /// Returns the number of rows that fit into the pixel buffer
+    /**
+     *  Per default the number of rows that fit into the pixel buffer
+     *  is identical to the height of the image.
+     *  However, in some cases there can be additional padding rows at
+     *  the bottom of an image (e.g. to support power-of-two textures).
+     */
+    virtual int getBufferHeight() const = 0;
+
+    /// Returns the pixel format of the image
+    virtual PIXEL_FORMAT getFormat() const = 0;
+
+    /// Provides read-only access to pixel data
+    virtual const void* getPixels() const = 0;
+
+protected:
+    virtual ~Image() {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_IMAGE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTargetResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTargetResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/ObjectTargetResult.h	(revision )
@@ -0,0 +1,41 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    ObjectTarget.h
+
+@brief
+    Header file for the ObjectTargetResult class.  Exposes the result of 
+    detecting and tracking a three dimensional rigid body.
+===============================================================================*/
+
+#ifndef _QCAR_OBJECTTARGETRESULT_H_
+#define _QCAR_OBJECTTARGETRESULT_H_
+
+// Include files
+#include <QCAR/TrackableResult.h>
+#include <QCAR/ObjectTarget.h>
+
+namespace QCAR
+{
+
+/// Result from detecting and tracking a rigid three dimensional body.
+class QCAR_API ObjectTargetResult : public TrackableResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const ObjectTarget& getTrackable() const = 0;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_OBJECTTARGETRESULT_H_
+
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/vcs.xml	(revision )
@@ -1,0 +1,0 @@
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ app/src/main/AndroidManifest.xml	(revision )
@@ -2,6 +2,16 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="fr.turfu.urbapp2">
 
+    <!-- Features needed for Augmented Reality with Vuforia-->
+    <uses-feature android:name="android.hardware.camera" />
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <!-- Checks for GLES version 20-->
+    <uses-feature android:glEsVersion="0x00020000"></uses-feature>
+
     <application
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
@@ -16,6 +26,7 @@
             </intent-filter>
         </activity>
         <activity android:name=".SettingsActivity"></activity>
+        <activity android:name=".AugmentedRealityActivity"></activity>
     </application>
 
 </manifest>
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButton.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButton.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VirtualButton.h	(revision )
@@ -0,0 +1,83 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    VirtualButton.h
+
+@brief
+    Header file for VirtualButton class.
+===============================================================================*/
+#ifndef _QCAR_VIRTUALBUTTON_H_
+#define _QCAR_VIRTUALBUTTON_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+class Area;
+
+
+/// A virtual button on a trackable
+/**
+ *  Methods to modify a VirtualButton must not be called while the
+ *  corresponding DataSet is active. The dataset must be deactivated first
+ *  before reconfiguring a VirtualButton.
+ */
+class QCAR_API VirtualButton : private NonCopyable
+{
+public:
+    /// Sensitivity of press detection
+    enum SENSITIVITY {
+        HIGH,           ///< Fast detection
+        MEDIUM,         ///< Balananced between fast and robust
+        LOW             ///< Robust detection
+    };
+
+    /// Defines a new area for the button area in 3D scene units (the
+    /// coordinate system is local to the ImageTarget).
+    /**
+     *  This method must not be called while the corresponding DataSet is
+     *  active or it will return false.
+     */
+    virtual bool setArea(const Area& area) = 0;
+
+    /// Returns the currently set Area
+    virtual const Area& getArea() const = 0;
+    
+    /// Sets the sensitivity of the virtual button
+    /**
+     *  Sensitivity allows deciding between fast and robust button press
+     *  measurements. This method must not be called while the corresponding
+     *  DataSet is active or it will return false.
+     */
+    virtual bool setSensitivity(SENSITIVITY sensitivity) = 0;
+
+    /// Enables or disables a virtual button
+    /**
+     *  This method must not be called while the corresponding DataSet is
+     *  active or it will return false.
+     */
+    virtual bool setEnabled(bool enabled) = 0;
+
+    /// Returns true if the virtual button is active (updates while tracking).
+    virtual bool isEnabled() const = 0;
+
+    /// Returns the name of the button as ASCII string.
+    virtual const char* getName() const = 0;
+
+    /// Returns a unique id for this virtual button.
+    virtual int getID() const = 0;
+
+protected:
+    virtual ~VirtualButton() {}
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_VIRTUALBUTTON_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetSearchResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetSearchResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetSearchResult.h	(revision )
@@ -0,0 +1,50 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TargetSearchResult.h
+
+@brief
+    Header file for TargetSearchResult class.
+===============================================================================*/
+#ifndef _QCAR_TARGET_SEARCH_RESULT_H_
+#define _QCAR_TARGET_SEARCH_RESULT_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+/// A search result of a found target returned by the TargetFinder
+class TargetSearchResult : private NonCopyable
+{
+public:
+    /// Returns the name of the target
+    virtual const char* getTargetName() const = 0;
+
+    /// Returns the system-wide unique id of the target.
+    virtual const char* getUniqueTargetId() const = 0;
+
+    /// Returns the width of the target (in 3D scene units)
+    virtual const float getTargetSize() const = 0;
+
+    /// Returns the metadata associated with this target
+    virtual const char* getMetaData() const = 0;
+
+    /// Returns the tracking rating for this target
+    /**
+     *  The tracking rating represents a 5-star rating describing the
+     *  suitability of this target for tracking on a scale from 0 to 5. A low
+     *  tracking rating may result in poor tracking or unstable augmentation.
+     */
+    virtual unsigned char getTrackingRating() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TARGET_SEARCH_RESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/PropResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/PropResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/PropResult.h	(revision )
@@ -0,0 +1,37 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    PropResult.h
+
+@brief
+    Header file for PropResult class.
+===============================================================================*/
+#ifndef _QCAR_PROPRESULT_H_
+#define _QCAR_PROPRESULT_H_
+
+// Include files
+#include <QCAR/TrackableResult.h>
+#include <QCAR/Prop.h>
+
+namespace QCAR
+{
+
+/// Result for a Prop generated by the SmartTerrainTracker.
+class QCAR_API PropResult : public TrackableResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const Prop& getTrackable() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_PROPRESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoMode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoMode.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/VideoMode.h	(revision )
@@ -0,0 +1,32 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    VideoMode.h
+
+@brief
+    Header file for VideoMode struct.
+===============================================================================*/
+#ifndef _QCAR_VIDEOMODE_H_
+#define _QCAR_VIDEOMODE_H_
+
+namespace QCAR
+{
+
+/// Implements access to the phone's built-in camera
+struct VideoMode
+{
+
+    VideoMode() : mWidth(0), mHeight(0), mFramerate(0.f) {}
+
+    int mWidth;       ///< Video frame width
+    int mHeight;      ///< Video frame height
+    float mFramerate; ///< Video frame rate
+};
+
+} // namespace QCAR
+
+#endif // _QCAR_VIDEOMODE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableSource.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableSource.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TrackableSource.h	(revision )
@@ -0,0 +1,34 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TrackableSource.h
+
+@brief
+    Header file for TrackableSource class.
+===============================================================================*/
+#ifndef _QCAR_TRACKABLESOURCE_H_
+#define _QCAR_TRACKABLESOURCE_H_
+
+// Include files:
+#include <QCAR/System.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+/// TrackableSource
+/**
+ *  An opaque handle for creating a new Trackable in a DataSet.
+ */
+class QCAR_API TrackableSource : private NonCopyable
+{
+
+};
+
+} // namespace QCAR
+
+#endif // _QCAR_TRACKABLESOURCE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Type.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Type.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Type.h	(revision )
@@ -0,0 +1,48 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Type.h
+
+@brief
+    Header file for Type class.
+===============================================================================*/
+#ifndef _QCAR_TYPE_H_
+#define _QCAR_TYPE_H_
+
+// Include files
+#include <QCAR/System.h>
+
+namespace QCAR
+{
+
+/// Class supporting a Vuforia-internal type system
+/**
+ *  The size of a Type class instance is only 16 bits, therefore
+ *  it should be passed around by value for efficiency reasons.
+ */
+class QCAR_API Type
+{
+public:
+    
+    Type();
+    Type(UInt16 data);
+
+    UInt16 getData() const;
+
+    /// Checks whether the type is an exact match with
+    /// or has been derived from another type:
+    bool isOfType(const Type type) const;
+
+private:
+    /// Internal type data:
+    UInt16 mData;
+};
+
+} // namespace QCAR
+
+
+#endif // _QCAR_TYPE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainBuilder.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainBuilder.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainBuilder.h	(revision )
@@ -0,0 +1,79 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    SmartTerrainBuilder.h
+
+@brief
+    Header file for SmartTerrainBuilder class.
+===============================================================================*/
+#ifndef _QCAR_SMARTTERRAIN_BUILDER_H_
+#define _QCAR_SMARTTERRAIN_BUILDER_H_
+
+// Include files
+#include <QCAR/Tracker.h>
+#include <QCAR/Trackable.h>
+#include <QCAR/Vectors.h>
+#include <QCAR/Reconstruction.h>
+
+
+namespace QCAR
+{
+
+/// SmartTerrainBuilder class
+/**
+ *  The SmartTerrainBuilder controls the smart terrain generation system of Vuforia.
+ *  If the SmartTerrainTracker is enabled and the builder is initialized. 
+ *  SmartTerrainTrackables (Surface, Prop) will be generated once an appropriate 
+ *  Reconstruction object is registered.
+ */
+class QCAR_API SmartTerrainBuilder : private NonCopyable
+{
+public:
+
+    /// Returns the Tracker class' type
+    static Type getClassType();    
+
+    /// Returns the Trackable instance's type
+    virtual Type getType() const = 0;
+
+    /// Checks whether the builder instance's type equals or has been
+    /// derived from a give type
+    virtual bool isOfType(Type type) const = 0;
+
+    // Factory method for creating an instance of a reconstruction 
+    /* 
+     * Valid types are ReconstructionFromEnvironment and ReconstructionFromTarget.
+     * Passing in any other type will cause NULL to be returned.
+     */
+    virtual Reconstruction* createReconstruction(Type type) = 0;
+
+    /// Method for cleaning up a previously created reconstruction object
+    virtual bool destroyReconstruction(Reconstruction* reco) = 0;
+
+    /// Returns the number of reconstructions registered with the builder.
+    virtual unsigned int getNumReconstructions() const = 0;
+
+    /// Adds a reconstruction to the builder and starts it.
+    virtual bool addReconstruction(Reconstruction* obj) = 0; 
+
+    /// Removes a reconstruction from the builder and cleans up any generated 
+    /// trackables as well.
+    virtual bool removeReconstruction(unsigned int index) = 0;
+
+    /// Gets the reconstruction at the given index.
+    virtual Reconstruction* getReconstruction(unsigned int index) const = 0;
+
+    /// Initializes the builder, returning true if able to.
+    virtual bool init() = 0;
+
+    /// Deinitializes the builder, return true if able to do so.
+    virtual bool deinit() = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_SMARTTERRAIN_BUILDER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb3D.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb3D.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Obb3D.h	(revision )
@@ -0,0 +1,62 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Obb2d.h
+
+@brief
+    Header file for Obb3d class.
+===============================================================================*/
+#ifndef _QCAR_OBB3D_H_
+#define _QCAR_OBB3D_H_
+
+
+#include <QCAR/QCAR.h>
+#include <QCAR/Vectors.h>
+
+
+namespace QCAR
+{
+
+
+/// An Obb3D represents a 3D bounding box oriented along z-direction
+class QCAR_API Obb3D
+{
+public:
+
+    /// Constructor.
+    Obb3D();
+
+    /// Copy constructor.
+    Obb3D(const Obb3D& other);
+
+    /// Construct from center, half extents and rotation.
+    Obb3D(const Vec3F& nCenter, const Vec3F& nHalfExtents,
+        float nRotationZ);
+
+    /// Returns the center of the bounding box.
+    virtual const Vec3F& getCenter() const;
+
+    /// Returns the half width, depth, and height of the bounding box.
+    virtual const Vec3F& getHalfExtents() const;
+
+    /// Returns the counter-clock-wise rotation angle (in radians) 
+    /// of the bounding box with respect to the Z axis.
+    virtual float getRotationZ() const;
+
+    virtual ~Obb3D();
+
+protected:
+    Vec3F center;
+    Vec3F halfExtents;
+    float rotation;
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_OBB3D_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Rectangle.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Rectangle.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Rectangle.h	(revision )
@@ -0,0 +1,96 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Rectangle.h
+
+@brief
+    Header file for Rectangle class.
+===============================================================================*/
+#ifndef _QCAR_RECTANGLE_H_
+#define _QCAR_RECTANGLE_H_
+
+#include <QCAR/Area.h>
+
+namespace QCAR
+{
+
+/// Rectangle defines a 2D rectangular area
+class QCAR_API Rectangle : public Area
+{
+public:
+    Rectangle();
+
+    Rectangle(const Rectangle& other);
+
+    Rectangle(float leftTopX, float leftTopY,
+              float rightBottomX, float rightBottomY);
+
+    virtual ~Rectangle();
+
+    Rectangle& operator=(const Rectangle& other);
+
+    float getLeftTopX() const;
+
+    float getLeftTopY() const;
+
+    float getRightBottomX() const;
+
+    float getRightBottomY() const;
+
+    float getWidth() const;
+
+    float getHeight() const;
+
+    float getAreaSize() const;
+
+    virtual TYPE getType() const;
+
+protected:
+    float left,top,right,bottom;
+};
+
+
+// Integer version of the Rectangle class
+class QCAR_API RectangleInt : public Area
+{
+public:
+    RectangleInt();
+
+    RectangleInt(const RectangleInt& other);
+
+    RectangleInt(int leftTopX, int leftTopY,
+        int rightBottomX, int rightBottomY);
+
+    virtual ~RectangleInt();
+
+    RectangleInt& operator=(const RectangleInt& other);
+
+    int getLeftTopX() const;
+
+    int getLeftTopY() const;
+
+    int getRightBottomX() const;
+
+    int getRightBottomY() const;
+
+    int getWidth() const;
+
+    int getHeight() const;
+
+    int getAreaSize() const;
+
+    virtual TYPE getType() const;
+
+protected:
+    int left,top,right,bottom;
+};
+
+} // namespace QCAR
+
+
+
+#endif // _QCAR_RECTANGLE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTargetResult.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTargetResult.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CylinderTargetResult.h	(revision )
@@ -0,0 +1,37 @@
+/*===============================================================================
+Copyright (c) 2013-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    CylinderTargetResult.h
+
+@brief
+    Header file for CylinderTargetResult class.
+===============================================================================*/
+#ifndef _QCAR_CYLINDERTARGETRESULT_H_
+#define _QCAR_CYLINDERTARGETRESULT_H_
+
+// Include files
+#include <QCAR/ObjectTargetResult.h>
+#include <QCAR/CylinderTarget.h>
+
+namespace QCAR
+{
+
+/// Result for a CylinderTarget.
+class QCAR_API CylinderTargetResult : public ObjectTargetResult
+{
+public:
+
+    /// Returns the TrackableResult class' type
+    static Type getClassType();
+
+    /// Returns the corresponding Trackable that this result represents
+    virtual const CylinderTarget& getTrackable() const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_CYLINDERTARGETRESULT_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/NonCopyable.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/NonCopyable.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/NonCopyable.h	(revision )
@@ -0,0 +1,36 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    NonCopyable.h
+
+@brief
+    Header file for NonCopyable class.
+===============================================================================*/
+#ifndef _QCAR_NONCOPYABLE_H_
+#define _QCAR_NONCOPYABLE_H_
+
+// Include files
+#include <QCAR/System.h>
+
+namespace QCAR
+{
+
+/// Base class for objects that can not be copied
+class QCAR_API NonCopyable
+{
+protected:
+    NonCopyable()  {}  ///< Standard constructor
+    ~NonCopyable()  {} ///< Standard destructor
+
+private: 
+    NonCopyable(const NonCopyable &);             ///< Hidden copy constructor
+    NonCopyable& operator= (const NonCopyable &); ///< Hidden assignment operator
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_NONCOPYABLE_H_
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/encodings.xml	(revision )
@@ -1,0 +1,0 @@
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTrackable.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTrackable.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/SmartTerrainTrackable.h	(revision )
@@ -0,0 +1,73 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    SmartTerrainTrackable.h
+
+@brief
+    Header file for SmartTerrainSmartTerrainTrackable class.
+===============================================================================*/
+#ifndef _QCAR_SMARTTERRAINTRACKABLE_H_
+#define _QCAR_SMARTTERRAINTRACKABLE_H_
+
+// Include files
+#include <QCAR/Trackable.h>
+
+namespace QCAR
+{
+
+// Forward declarations:
+class Rectangle;
+class Mesh;
+
+/// The base class of all SmartTerrain trackables 
+/**
+ * The SmartTerrainTrackable class represents any trackable that is
+ *  reconstructed  and tracked by the SmartTerrainTracker. It provides access
+ *  to all common properties. SmartTerrainTrackables are reconstructed in an
+ *  object graph. Elements of this hierarchy are the derived classes
+ *  Surface and Prop. A Surface represents navigable ground plane and may 
+ *  have multiple Prop child objects that represent objects on this plane.
+ */
+class QCAR_API SmartTerrainTrackable : public Trackable
+{
+public:
+
+    /// Returns the Trackable class' type
+    static Type getClassType();
+
+    /// Returns the mesh that represents this SmartTerrainTrackable
+    /**
+     *  The mesh represents either a ground Surface or a Prop on top of the
+     *  Surface depending on the derived class. The mesh will change over time.
+     */
+    virtual const Mesh* getMesh() const = 0;
+    
+    /// Returns the mesh revision, which is increased on every geometry update
+    virtual int getRevision() const = 0;
+
+    /// Get the local pose relative to the parent SmartTerrainTrackable
+    virtual const Matrix34F& getLocalPose() const = 0;
+
+    /// Returns the parent SmartTerrainTrackable
+    /**
+     *  Returns NULL if this is the root object
+     */
+    virtual const SmartTerrainTrackable* getParent() const = 0;
+
+    /// Returns the number of SmartTerrainTrackable child objects
+    virtual unsigned int getChildrenCount() const = 0;
+
+    /// Returns the SmartTerrainTrackable child object at at the given index
+    /**
+     *  Returns NULL if the index is invalid.
+     */
+    virtual const SmartTerrainTrackable* getChild(unsigned int idx) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_SMARTTERRAINTRACKABLE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/Texture.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/Texture.java	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/Texture.java	(revision )
@@ -0,0 +1,99 @@
+package fr.turfu.urbapp2.AR;
+
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Created by Julien Vuillamy on 08/03/16.
+ * Inspired by the Texture class from VuforiaSamples
+ * https://developer.vuforia.com/downloads/samples
+ */
+
+public class Texture {
+
+    private static final String LOGTAG = "Texture";
+
+    public int mWidth ;
+    public int mHeight;
+    public ByteBuffer mData ;
+    public int[] mTextureID= new int[1];
+
+    public static Texture loadTextureFromApk(String fileName, AssetManager assets) {
+        InputStream inputStream;
+        try
+        {
+            inputStream = assets.open(fileName, AssetManager.ACCESS_BUFFER);
+
+            BufferedInputStream bufferedStream = new BufferedInputStream(
+                    inputStream);
+            Bitmap bitMap = BitmapFactory.decodeStream(bufferedStream);
+
+            int[] data = new int[bitMap.getWidth() * bitMap.getHeight()];
+            bitMap.getPixels(data, 0, bitMap.getWidth(), 0, 0,
+                    bitMap.getWidth(), bitMap.getHeight());
+
+            return loadTextureFromIntBuffer(data, bitMap.getWidth(),
+                    bitMap.getHeight());
+        } catch (IOException e)
+        {
+            Log.e(LOGTAG, "Failed to log texture '" + fileName + "' from APK");
+            Log.i(LOGTAG, e.getMessage());
+            return null;
+        }
+    }
+
+    public static Texture loadTexture(Bitmap bitmap)
+    {
+
+        int[] data = new int[bitmap.getWidth() * bitmap.getHeight()];
+        bitmap.getPixels(data, 0, bitmap.getWidth(), 0, 0,
+                bitmap.getWidth(), bitmap.getHeight());
+
+        return loadTextureFromIntBuffer(data, bitmap.getWidth(),
+                bitmap.getHeight());
+    }
+    private static Texture loadTextureFromIntBuffer(int[] data, int width, int height) {
+        // Convert:
+        int numPixels = width * height;
+        byte[] dataBytes = new byte[numPixels * 4];
+
+        for (int p = 0; p < numPixels; ++p)
+        {
+            int colour = data[p];
+            dataBytes[p * 4] = (byte) (colour >>> 16); // R
+            dataBytes[p * 4 + 1] = (byte) (colour >>> 8); // G
+            dataBytes[p * 4 + 2] = (byte) colour; // B
+            dataBytes[p * 4 + 3] = (byte) (colour >>> 24); // A
+        }
+
+        Texture texture = new Texture();
+        texture.mWidth = width;
+        texture.mHeight = height;
+
+        texture.mData = ByteBuffer.allocateDirect(dataBytes.length).order(
+                ByteOrder.nativeOrder());
+
+        int rowSize = texture.mWidth * 4;
+        for (int r = 0; r < texture.mHeight; r++)
+            texture.mData.put(dataBytes, rowSize * (texture.mHeight - 1 - r),
+                    rowSize);
+
+        texture.mData.rewind();
+
+        // Cleans variables
+        dataBytes = null;
+        data = null;
+
+        return texture;
+    }
+
+
+}
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Eyewear.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Eyewear.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Eyewear.h	(revision )
@@ -0,0 +1,159 @@
+/*==============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other
+countries.
+
+@file 
+    Eyewear.h
+
+@brief
+    Header file for Eyewear class.
+==============================================================================*/
+#ifndef _QCAR_EYEWEAR_H_
+#define _QCAR_EYEWEAR_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/Matrices.h>
+#include <QCAR/CameraCalibration.h>
+#include <QCAR/EyeID.h>
+#include <QCAR/EyewearCalibrationProfileManager.h>
+#include <QCAR/EyewearUserCalibrator.h>
+
+namespace QCAR
+{
+
+/// Class that provides functionality specific to AR on Eyewear devices.
+/**
+ *
+ * <br><b>This API is only supported in the Vuforia SDK for Digital %Eyewear.</b><br><br>
+ *
+ * Digital %Eyewear integration provides methods to detect and control an
+ * Eyewear device and to retrieve calibration data needed to correctly
+ * register augmentations with the real world.
+ */
+class QCAR_API Eyewear : private NonCopyable
+{
+public:
+
+    /// Calibration profile ID for the current active profile.
+    static const int EYEWEAR_PROFILE_ACTIVE = -1;
+    /// Calibration profile ID for the default calibration.
+    static const int EYEWEAR_PROFILE_DEFAULT = 0;
+
+    enum ORIENTATION
+    {
+        ORIENTATION_UNDEFINED = 0,
+        ORIENTATION_PORTRAIT,
+        ORIENTATION_LANDSCAPE_LEFT,
+        ORIENTATION_LANDSCAPE_RIGHT
+    };
+
+    /// Get the singleton instance
+    static Eyewear& getInstance();
+
+    /// Returns true if an Eyewear device is present, false otherwise.
+    virtual bool isDeviceDetected() = 0;
+
+    /// Inform Vuforia that the device has been inserted into a headset
+    /**
+     * <br><b>In order to use optimal camera settings you should call this
+     * method before starting the camera. If the camera is already started
+     * you should stop, deinitialize, initialize and restart it.</b><br>
+     * Known identifier strings: "GearVR", "Cardboard"
+     * \param id the identifier string for the headset (case insensitive)
+     * \return true if successful, false if the detected device is a dedicated
+     *         eyewear device, the camera has not been deinitialized, or no
+     *         valid headset is found.
+     */
+    virtual bool setHeadsetPresent(const char* id) = 0;
+
+    /// Inform Vuforia that the device has been removed from a headset.
+    /**
+     * \return true if successful, false if the detected device is a dedicated eyewear device.
+     */
+    virtual bool setHeadsetNotPresent() = 0;
+
+    /// Returns true if the Eyewear device detected has a see-through display.
+    virtual bool isSeeThru() = 0;
+
+    /// Returns the correct screen orientation to use when rendering for the eyewear device.
+    virtual ORIENTATION getScreenOrientation() = 0;
+
+    /// Returns true if the Eyewear device has a stereo display, false otherwise.
+    virtual bool isStereoCapable() = 0;
+
+    /// Returns true if the Eyewear device is in stereo mode
+    virtual bool isStereoEnabled() = 0;
+
+    /// Returns true if the Eyewear device stereo mode is only for OpenGL content.
+    /**
+     * Some Eyewear devices don't support stereo for 2D (typically Android widget)
+     * content. On these devices 2D content is rendered to each eye automatically
+     * without the need for the app to create a split screen view. On such devices
+     * this method will return true.
+     */
+    virtual bool isStereoGLOnly() = 0;
+
+    /// Switch between 2D (mono) and 3D (stereo) modes on eyewear device.
+    /**
+     * \param enable set to true to switch to 3D (stereo) mode or false for 2D (mono) mode
+     * \return true if successful or false if the device doesn't support this operation.
+     */
+    virtual bool setStereo(bool enable) = 0;
+
+    /// Returns true if predictive tracking is enabled
+    virtual bool isPredictiveTrackingEnabled() = 0;
+
+    /// Turn predictive tracking on or off
+    /**
+     * Predictive tracking uses device sensors to predict user motion and reduce perceived latency.
+     * By default predictive tracking is enabled on devices that support this enhancement.
+     * \param enable set to true to enable predictive tracking or false to disable predictive tracking.
+     * \return true if successful or false if the device doesn't support this operation.
+     */
+    virtual bool setPredictiveTracking(bool enable) = 0;
+
+    /// Get the calibration profile manager.
+    /**
+     * Note: Calibration profiles are only relevant to see-through Eyewear devices.
+     * \return A reference to the calibration profile manager.
+     */
+    virtual EyewearCalibrationProfileManager& getProfileManager() = 0;
+
+    /// Specify the near and far planes used in the projection matrix
+    /**
+     * At this time these values are only used for generating the
+     * projection matrix on occluded devices (video see-through).
+     */
+    virtual void setProjectionClippingPlanes(const CameraCalibration& cameraCalibration, float nearPlane, float farPlane) = 0;
+
+    /// Get the projection matrix for the specified eye
+    /**
+     * \param eyeID the eye to get the calibrated projection matrix for, one of \link EYEID_MONOCULAR  \endlink, \link EYEID_LEFT \endlink or \link EYEID_RIGHT \endlink.
+     * \param profileID the calibration profile to use, this defaults to the active profile.
+     */
+    virtual Matrix44F getProjectionMatrix(EYEID eyeID, int profileID = EYEWEAR_PROFILE_ACTIVE) = 0;
+
+    /// Get an orthographic projection correct for the stereo rendering of the current device.
+    /**
+     * This projection is typically used for the rendering the video background.
+     * When rendering for a stereo device it is common for the device to provide a surface equal
+     * to the display area of each screen, the device stretches each half of the display to fill
+     * each screen. However some devices provide a surface equal to the total display area for
+     * both eyes and does not stretch the image. This method returns a projection corrected to be
+     * appropriate to the device that the app is running on.
+     */
+    virtual Matrix44F getOrthographicProjectionMatrix() = 0;
+
+    /// Gets the calibrator used for creating custom user calibration experiences
+    /**
+     * \return A reference to the calibrator object
+     */
+    virtual EyewearUserCalibrator& getCalibrator() = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_EYEWEAR_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Box3D.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Box3D.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Box3D.h	(revision )
@@ -0,0 +1,53 @@
+/*===============================================================================
+Copyright (c) 2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Box3D.h
+
+@brief
+    Header file for Box3D class.
+===============================================================================*/
+#ifndef _QCAR_BOX3D_H_
+#define _QCAR_BOX3D_H_
+
+#include <QCAR/QCAR.h>
+#include <QCAR/Vectors.h>
+
+namespace QCAR
+{
+
+/// A Box3D represents an axis-aligned 3D box
+class QCAR_API Box3D
+{
+public:
+
+    /// Constructor.
+    Box3D();
+
+    /// Copy constructor.
+    Box3D(const Box3D& other);
+
+    /// Define a box by its minimum and maximum position.
+    Box3D(const Vec3F& nMinPos, const Vec3F& nMaxPos);
+
+    /// Returns the minimum position of the box.
+    virtual const Vec3F& getMinimumPosition() const;
+
+    /// Returns the maximum position of the box.
+    virtual const Vec3F& getMaximumPosition() const;
+
+    virtual ~Box3D();
+
+protected:
+    Vec3F minimumPosition;
+    Vec3F maximumPosition;
+};
+
+
+} // namespace QCAR
+
+
+#endif // _QCAR_BOX3D_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Renderer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Renderer.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Renderer.h	(revision )
@@ -0,0 +1,170 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Renderer.h
+
+@brief
+    Header file for Renderer class.
+===============================================================================*/
+#ifndef _QCAR_RENDERER_H_
+#define _QCAR_RENDERER_H_
+
+// Include files
+#include <QCAR/Matrices.h>
+#include <QCAR/Vectors.h>
+#include <QCAR/State.h>
+#include <QCAR/NonCopyable.h>
+#include <QCAR/QCAR.h>
+
+namespace QCAR 
+{
+
+// Forward declarations
+class State;
+struct VideoBackgroundConfig;
+struct VideoBackgroundTextureInfo;
+
+/// Renderer class
+/**
+ * The Renderer class provides methods to fulfill typical AR related tasks
+ * such as rendering the video background and 3D objects with up to date
+ * pose data. It also exposes methods for configuring the rendering frame rate
+ * in both AR and VR use cases. Some methods of the Renderer class must only be
+ * called from the render thread.
+ */
+class QCAR_API Renderer : private NonCopyable
+{
+public:
+
+    /// Application behavior aspects influencing the recommended render frame
+    /// rate. Use as parameters to getRecommendedFps.
+    enum FPSHINT_FLAGS
+    {
+        //// No FPS hint defined
+        FPSHINT_NONE = 0,
+
+        /// The application does not draw the video background (in optical see-
+        /// through AR or VR mode). Do not set this flag when in video see-
+        /// through AR mode.
+        FPSHINT_NO_VIDEOBACKGROUND = 1 << 0,
+
+        /// The application requests conservative power consumption to reduce
+        /// heat accumulation and increase battery life. On some devices this
+        /// may be at the cost of reduced application performance and decreased
+        /// quality of experience.
+        FPSHINT_POWER_EFFICIENCY = 1 << 1,
+
+        /// The application uses content that requires a high rendering rate, 
+        /// E.g. using smooth character animation or updating a physics engine.
+        FPSHINT_FAST = 1 << 2,
+
+        /// Default flags used by Vuforia to determine FPS settings
+        FPSHINT_DEFAULT_FLAGS = FPSHINT_NONE
+    };
+
+    /// Target FPS value representing continuous rendering.
+    static const int TARGET_FPS_CONTINUOUS;
+
+    /// Returns the Renderer singleton instance.
+    static Renderer& getInstance();
+
+    /// Marks the beginning of rendering for the current frame and returns the
+    /// State object.
+    /**
+    *  Returns the latest available State object. This state object may hold
+    *  predicted Trackable poses if predicted tracking is turned on and
+    *  available on the device. Please see Eyewear::setPredictiveTracking()
+    *  for more details. Must only be called from the render thread.
+    */
+    virtual State begin() = 0;
+
+    /// Marks the beginning of rendering for the given frame.
+    /**
+    *  Use this to draw a specific camera frame, rather than the latest
+    *  available one. Must only be called from the render thread.
+    */
+    virtual void begin(State state) = 0;
+
+    /// Draws the video background
+    /**
+    *  This should only be called between a begin() and end() calls.
+    *  Must only be called from the render thread.
+    */
+    virtual bool drawVideoBackground() = 0;
+
+    /// Marks the end of rendering for the current frame.
+    /**
+    *  Must only be called from the render thread.
+    */
+    virtual void end() = 0;
+
+    /// Binds the video background texture to a given texture unit
+    /**
+    *  This should only be called between a begin() and end() calls.
+    *  Must only be called from the render thread.
+    */
+    virtual bool bindVideoBackground(int unit) = 0;
+
+    /// Configures the layout of the video background (location/size on screen
+    virtual void setVideoBackgroundConfig(const VideoBackgroundConfig& cfg) = 0;
+    
+    /// Retrieves the current layout configuration of the video background
+    virtual const VideoBackgroundConfig& getVideoBackgroundConfig() const = 0;
+
+    /// Returns the texture info associated with the current video background
+    virtual const VideoBackgroundTextureInfo& 
+                                      getVideoBackgroundTextureInfo() = 0;
+
+    /// Sets the texture id to use for updating video background data
+    /**
+    *  Use this in conjunction with bindVideoBackground. Must only be called
+    *  from the render thread.
+    */
+    virtual bool setVideoBackgroundTextureID(int textureID) = 0;
+
+    /// Calculate a perspective projection matrix and apply it to OpenGL
+    /**
+    *  Must only be called from the render thread.
+    */
+    virtual void setARProjection(float nearPlane, float farPlane) = 0;
+
+    // Set a target rendering frame rate in frames per second
+    /**
+    *  Request a rendering frame rate that the application should target in its
+    *  render loop. It is not guaranteed that the application and the device
+    *  are able to deliver this frame rate. Use a fixed application setting such
+    *  as '30', or '60' or query Renderer::getDefaultFps() to get
+    *  a recommended fps setting from Vuforia. Use TARGET_FPS_CONTINUOUS to set
+    *  continuous rendering if supported by given platform. Returns true if the 
+    *  rate was set successfully, false otherwise.
+    */    
+    virtual bool setTargetFps(int fps) = 0;
+
+    // Query recommended rendering frame rate based on application hints
+    /**
+    *  The target rendering frame rate of an AR or VR application is an
+    *  important trade-off between optimal experience and device power usage.
+    *  The choice is influenced by multiple parameters including device type,
+    *  the active Trackers, the camera and/or sensor frame rates. Furthermore
+    *  there are application specific trade offs to consider. These hints can be
+    *  passed to the function as parameters (see FPS_HINT_FLAGS). For example,
+    *  an application with animated content may need consistent 60 fps rendering
+    *  even on a device that can only deliver poses at 30 fps. getDefaultFps 
+    *  considers the device parameters as well as the application specific hints
+    *  and returns a recommended frame rate. The returned value can then be set
+    *  via setTargetFps. Note that getDefaultFps may return different values
+    *  tuned to the active CameraDevice::Mode and active Trackers. Thus it is
+    *  recommended to call this API after the application has completed the
+    *  camera and tracker setup as well as when an application transitions
+    *  between modes (For example when transitioning between AR to VR modes)
+    */
+    virtual int getRecommendedFps(int flags = FPSHINT_DEFAULT_FLAGS) const = 0;
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_RENDERER_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Vectors.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Vectors.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/Vectors.h	(revision )
@@ -0,0 +1,134 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    Vectors.h
+
+@brief
+    Header file for vector structs.
+===============================================================================*/
+#ifndef _QCAR_VECTOR_H_
+#define _QCAR_VECTOR_H_
+
+namespace QCAR 
+{
+
+/// 2D vector of float items
+struct Vec2F
+{
+    Vec2F()  {}
+
+    Vec2F(const float* v)
+    {
+        for(int i=0; i<2; i++)
+            data[i]= v[i];
+    }
+
+    Vec2F(float v0, float v1)
+    {
+        data[0] = v0;
+        data[1] = v1;
+    }
+
+    float data[2];
+};
+
+
+/// 3D vector of float items
+struct Vec3F
+{
+    Vec3F()  {}
+
+    Vec3F(const float* v)
+    {
+        for(int i=0; i<3; i++)
+            data[i]= v[i];
+    }
+
+    Vec3F(float v0, float v1, float v2)
+    {
+        data[0] = v0;
+        data[1] = v1;
+        data[2] = v2;
+    }
+
+    float data[3];
+};
+
+
+/// 4D vector of float items
+struct Vec4F
+{
+    Vec4F()  {}
+
+    Vec4F(const float* v)
+    {
+        for(int i=0; i<4; i++)
+            data[i]= v[i];
+    }
+
+    Vec4F(float v0, float v1, float v2, float v3)
+    {
+        data[0] = v0;
+        data[1] = v1;
+        data[2] = v2;
+        data[3] = v3;
+    }
+
+    float data[4];
+};
+
+
+/// 2D vector of int items
+struct Vec2I
+{
+    Vec2I()  {}
+    Vec2I(const int* v)
+    {
+        for(int i=0; i<2; i++)
+            data[i]= v[i];
+    }
+
+    Vec2I(int v0, int v1)
+    {
+        data[0] = v0;
+        data[1] = v1;
+    }
+
+    int data[2];
+};
+
+
+/// 3D vector of int items
+struct Vec3I
+{
+    Vec3I()  {}
+    Vec3I(const int* v)
+    {
+        for(int i=0; i<3; i++)
+            data[i]= v[i];
+    }
+
+    int data[3];
+};
+
+
+/// 4D vector of int items
+struct Vec4I
+{
+    Vec4I()  {}
+    Vec4I(const int* v)
+    {
+        for(int i=0; i<4; i++)
+            data[i]= v[i];
+    }
+
+    int data[4];
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_VECTOR_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/State.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/State.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/State.h	(revision )
@@ -0,0 +1,88 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    State.h
+
+@brief
+    Header file for State class.
+===============================================================================*/
+#ifndef _QCAR_STATE_H_
+#define _QCAR_STATE_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/Frame.h>
+
+namespace QCAR
+{
+
+class Trackable;
+class TrackableResult;
+class StateData;
+
+
+/// AR State
+/**
+ *  A consistent view on the augmented reality state
+ *  including a camera frame and all trackables.
+ *  Similar to Frame, State is a light weight object that
+ *  shares its data among multiple instances. Copies are
+ *  therefore cheap and suggested over usage of references.
+ *  Notice: Trackables queried by the state can not be
+ *  compared by pointer to Trackables queried by the tracker
+ *  (even though they might reference the same tracked object).
+ *  Trackables queried by the state represent a temporary and
+ *  consistent view on the Augmented Reality state and can
+ *  therefore not be modified. objects must be queried from
+ *  the Tracker in order to modify them.
+ */
+class QCAR_API State
+{
+public:
+    /// Default constructor.
+    State();
+
+    /// Copy constructor.
+    State(const State& other);
+
+    /// Destructor
+    ~State();
+
+    /// Thread safe assignment operator
+    State& operator=(const State& other);
+
+    /// Returns the Frame object that is stored in the State
+    Frame getFrame() const;
+
+    /// Returns the number of Trackable objects currently known to the SDK
+    int getNumTrackables() const;
+
+    /// Provides access to a specific Trackable
+    /**
+     *  The returned object is only valid as long as the State
+     *  object is valid. Do not keep a copy of the pointer!
+     */
+    const Trackable* getTrackable(int idx) const;
+
+    /// Returns the number of Trackable objects currently being tracked
+    int getNumTrackableResults() const;
+
+    /// Provides access to a specific TrackableResult object.
+    /**
+     *  The returned object is only valid as long as the State
+     *  object is valid. Do not keep a copy of the pointer!
+     */
+    const TrackableResult* getTrackableResult(int idx) const;
+
+protected:
+    StateData* mData;
+
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_STATE_H_
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision 58113b8771400c6c40f627832450614cbfc38def)
+++ .idea/compiler.xml	(revision )
@@ -1,0 +1,0 @@
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraCalibration.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraCalibration.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraCalibration.h	(revision )
@@ -0,0 +1,49 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    CameraCalibration.h
+
+@brief
+    Header file for CameraCalibration class.
+===============================================================================*/
+#ifndef _QCAR_CAMERACALIBRATION_H_
+#define _QCAR_CAMERACALIBRATION_H_
+
+// Include files
+#include <QCAR/Vectors.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+/// Holds intrinsic camera parameters
+class QCAR_API CameraCalibration : private NonCopyable
+{
+public:
+    /// Returns the resolution of the camera as 2D vector.
+    virtual Vec2F getSize() const = 0;
+
+    /// Returns the focal length in x- and y-direction as 2D vector.
+    virtual Vec2F getFocalLength() const = 0;
+
+    /// Returns the principal point as 2D vector.
+    virtual Vec2F getPrincipalPoint() const = 0;
+
+    /// Returns the radial distortion as 4D vector.
+    virtual Vec4F getDistortionParameters() const = 0;
+
+    /// Returns the field of view in x- and y-direction as 2D vector.
+    virtual Vec2F getFieldOfViewRads() const = 0;
+
+protected:
+
+    virtual ~CameraCalibration() {}
+};
+
+} // namespace QCAR
+
+#endif // _QCAR_CAMERACALIBRATION_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraDevice.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraDevice.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/CameraDevice.h	(revision )
@@ -0,0 +1,123 @@
+/*===============================================================================
+Copyright (c) 2010-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    CameraDevice.h
+
+@brief
+    Header file for CameraDevice class.
+===============================================================================*/
+#ifndef _QCAR_CAMERADEVICE_H_
+#define _QCAR_CAMERADEVICE_H_
+
+// Include files
+#include <QCAR/NonCopyable.h>
+#include <QCAR/VideoMode.h>
+#include <QCAR/CameraCalibration.h>
+
+namespace QCAR
+{
+
+/// Implements access to the phone's built-in camera
+class QCAR_API CameraDevice : private NonCopyable
+{
+public:
+    enum MODE
+    {
+        MODE_DEFAULT = -1,                ///< Default camera mode
+        MODE_OPTIMIZE_SPEED = -2,         ///< Fast camera mode
+        MODE_OPTIMIZE_QUALITY = -3,       ///< High-quality camera mode
+    };
+
+    enum FOCUS_MODE 
+    {
+        FOCUS_MODE_NORMAL,           ///< Default focus mode
+        FOCUS_MODE_TRIGGERAUTO,      ///< Triggers a single autofocus operation
+        FOCUS_MODE_CONTINUOUSAUTO,   ///< Continuous autofocus mode
+        FOCUS_MODE_INFINITY,         ///< Focus set to infinity
+        FOCUS_MODE_MACRO             ///< Macro mode for close-up focus
+    };
+
+    enum CAMERA
+    {
+        CAMERA_DEFAULT,              ///< Default camera device.  Usually BACK
+        CAMERA_BACK,                 ///< Rear facing camera
+        CAMERA_FRONT                 ///< Front facing camera
+    };
+
+    /// Returns the CameraDevice singleton instance.
+    static CameraDevice& getInstance();
+
+    /// Initializes the camera.
+    virtual bool init(CAMERA camera = CAMERA_DEFAULT) = 0;
+
+    /// Deinitializes the camera.
+    /**
+     *  Any resources created or used so far are released. Note that this
+     *  function should not be called during the execution of the
+     *  UpdateCallback and if so will return false.
+     */
+    virtual bool deinit() = 0;
+
+    /// Starts the camera. Frames are being delivered.
+    /**
+     *  Depending on the type of the camera it may be necessary to perform
+     *  configuration tasks before it can be started.
+     */
+    virtual bool start() = 0;
+
+    /// Stops the camera if video feed is not required (e.g. in non-AR mode
+    /// of an application).
+    virtual bool stop()  = 0;
+
+    /// Returns the number of available video modes.
+    /**
+     *  This is device specific and can differ between mobile devices or operating
+     *  system versions.
+     */
+    virtual int getNumVideoModes() = 0;
+
+    /// Returns the video mode currently selected.
+    /**
+     *  If no video mode is set then Vuforia chooses a video mode.
+     */
+    virtual VideoMode getVideoMode(int nIndex) = 0;
+
+    /// Chooses a video mode out of the list of modes
+    /*
+     *  This function can be only called after the camera device has been
+     *  initialized but not started yet. Once you have started the camera and
+     *  you need the select another video mode, you need to stop(), deinit(),
+     *  then init() the camera before calling selectVideoMode() again.
+     */
+    virtual bool selectVideoMode(int index) = 0;
+
+    /// Provides read-only access to camera calibration data.
+    virtual const CameraCalibration& getCameraCalibration() const = 0;
+
+    /// Enable/disable torch mode if the device supports it.
+    /**
+     *  Returns true if the requested operation was successful, False
+     *  otherwise.
+     */
+    virtual bool setFlashTorchMode(bool on) = 0;
+
+    /// Set the requested focus mode if the device supports it.
+    /**
+     *  The allowed values are FOCUS_MODE_NORMAL, FOCUS_MODE_TRIGGERAUTO,
+     *  FOCUS_MODE_CONTINUOUSAUTO, FOCUS_MODE_INFINITY, FOCUS_MODE_MACRO,
+     *  though not all modes are supported on all devices. Returns true if
+     *  the requested operation was successful, False otherwise.
+     *  Also note that triggering a single autofocus event using 
+     *  FOCUS_MODE_TRIGGERAUTO may stop continuous autofocus if that focus
+     *  mode was set earlier.
+     */
+    virtual bool setFocusMode(int focusMode) = 0;
+};
+
+} // namespace QCAR
+
+#endif // _QCAR_CAMERADEVICE_H_
Index: app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetFinder.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetFinder.h	(revision )
+++ app/src/main/java/fr/turfu/urbapp2/AR/VuforiaSDK/build/include/QCAR/TargetFinder.h	(revision )
@@ -0,0 +1,186 @@
+/*===============================================================================
+Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved.
+
+Vuforia is a trademark of PTC Inc., registered in the United States and other 
+countries.
+
+@file 
+    TargetFinder.h
+
+@brief
+    Header file for TargetFinder class.
+===============================================================================*/
+#ifndef _QCAR_TARGET_FINDER_H_
+#define _QCAR_TARGET_FINDER_H_
+
+// Include files
+#include <QCAR/System.h>
+#include <QCAR/TargetSearchResult.h>
+#include <QCAR/NonCopyable.h>
+
+namespace QCAR
+{
+
+// Forward Declaration
+class DataSet;
+class ImageTarget;
+
+/// A service that retrieves Targets using cloud-based recognition
+class QCAR_API TargetFinder : private NonCopyable
+{
+public:
+
+    /// Status codes returned by the init() function
+    enum
+    {
+        INIT_DEFAULT = 0,                        ///< Initialization has not started
+        INIT_RUNNING = 1,                        ///< Initialization is running
+        INIT_SUCCESS = 2,                        ///< Initialization completed successfully
+        INIT_ERROR_NO_NETWORK_CONNECTION = -1,   ///< No network connection
+        INIT_ERROR_SERVICE_NOT_AVAILABLE = -2    ///< Service is not available
+    };
+
+    /// Status codes returned by the updateSearchResults() function
+    enum
+    {
+        UPDATE_NO_MATCH = 0,                     ///< No matches since the last update
+        UPDATE_NO_REQUEST = 1,                   ///< No recognition request since the last update
+        UPDATE_RESULTS_AVAILABLE = 2,            ///< New search results have been found
+        UPDATE_ERROR_AUTHORIZATION_FAILED = -1,  ///< Credentials are wrong or outdated
+        UPDATE_ERROR_PROJECT_SUSPENDED = -2,     ///< The specified project was suspended.
+        UPDATE_ERROR_NO_NETWORK_CONNECTION = -3, ///< Device has no network connection
+        UPDATE_ERROR_SERVICE_NOT_AVAILABLE = -4, ///< Server not found, down or overloaded.
+        UPDATE_ERROR_BAD_FRAME_QUALITY = -5,     ///< Low frame quality has been continuously observed
+        UPDATE_ERROR_UPDATE_SDK = -6,            ///< SDK Version outdated.
+        UPDATE_ERROR_TIMESTAMP_OUT_OF_RANGE = -7,///< Client/Server clocks too far away.
+        UPDATE_ERROR_REQUEST_TIMEOUT = -8        ///< No response to network request after timeout.
+    };
+
+    /// Filter modes to be passed into updateSearchResults() function
+    enum
+    {
+        FILTER_NONE = 0, 	///< No results are filtered, all successful queries are returned
+        FILTER_CURRENTLY_TRACKED = 1  ///< Filter out targets that are currently being tracked (Most Common)
+    };
+
+    /// Starts initialization of the cloud-based recognition system.
+    /**
+     * Initialization of the cloud-based recognition system may take significant
+     * time and is thus handled in a background process. Use getInitState() to
+     * query the initialization progress and result. Pass in the user/password
+     * for authenticating with the visual search server.
+     */
+    virtual bool startInit(const char* userAuth, const char* secretAuth) = 0;
+
+     /// Returns the current state of the initialization process
+    /**
+     * Returns INIT_SUCCESS if the cloud-based recognition system was
+     * initialized successfully. Initialization requires a network connection
+     * to be available on the device, otherwise INIT_ERROR_NO_NETWORK_CONNECTION
+     * is returned. If the cloud-based recognition service is not available this
+     * function will return INIT_ERROR_SERVICE_NOT_AVAILABLE. Returns
+     * INIT_DEFAULT if initialization has not been started. Returns INIT_RUNNING
+     * if the initialization process has not completed.
+     */
+    virtual int getInitState() = 0;
+
+    /// Wait for the the cloud-based recognition system initialization to complete.
+    /**
+     * This functions blocks execution until initialization is complete.
+     */
+    virtual void waitUntilInitFinished() = 0;
+
+    /// Deinitializes the cloud-based recognition system
+    virtual bool deinit() = 0;
+    
+
+    /// Starts visual recognition
+    /**
+     *  Starts continuous recognition of Targets from the cloud.
+     *  Use updateSearchResults() and getResult() to retrieve search matches.
+     */
+    virtual bool startRecognition() = 0;
+
+    /// Stops visual recognition
+    virtual bool stop() = 0;
+
+
+
+    /// Returns true if the TargetFinder is in 'requesting' mode
+    /**
+     *  When in 'requesting' mode the TargetFinder has issued a search 
+     *  query to the recognition server and is waiting for the results.
+     */
+    virtual bool isRequesting() = 0;
+
+
+
+    /// Update visual search results
+    /**
+     *  Clears and rebuilds the list of TargetSearchResults with results found
+     *  since the last call to updateSearchResults(). Returns the status code
+     *  UPDATE_RESULTS_AVAILABLE if new search results have been found.
+     *  By default, targets that are already enabled for tracking are not included
+     *  in the list of TargetSearchResults unless the target or its associated
+     *  meta data has been updated since they were last enabled for tracking.
+     */
+    virtual int updateSearchResults(int filter = FILTER_CURRENTLY_TRACKED) = 0;
+
+    /// Get the number of visual search results
+    virtual int getResultCount() const = 0;
+
+    /// Returns a pointer to a search result instance
+    /**
+     *  Search results are owned by the TargetFinder. Each call to
+     *  updateSearchResults() destroys and rebuilds the list of
+     *  TargetSearchResult search.
+     */
+    virtual const TargetSearchResult* getResult(int idx) = 0;
+
+
+
+    /// Enable this search result for tracking
+    /**
+     *  Creates an ImageTarget for local detection and tracking of this target.
+     *  The pose of this target will be reported in the Vuforia State. Note that
+     *  this call may result in an earlier ImageTarget that was enabled for
+     *  tracking to be destroyed. Thus it is not advised to hold a pointer to an
+     *  earlier created ImageTarget after calling enableTracking again. Returns
+     *  NULL if the target failed to be enabled for tracking.
+     */
+    virtual ImageTarget* enableTracking(const TargetSearchResult& result) = 0;
+    
+    /// Clears all targets enabled for tracking
+    /**
+     *  Destroy all ImageTargets that have been created via enableTracking().
+     */
+    virtual void clearTrackables() = 0;
+
+    /// Returns the number targets currently enabled for tracking.
+    virtual int getNumImageTargets() const = 0;
+    
+    /// Returns a pointer to an ImageTarget object.
+    virtual ImageTarget* getImageTarget(int idx) = 0;
+
+
+
+    /// Sets the base color of the scanline in the scanning UI
+    /**
+     * The parameters allow you to set the Red, Green and Blue colors 
+     * for the Scanline. They should be normalized values between 0 and 1.
+     */
+    virtual void setUIScanlineColor(float r, float g, float b) = 0; 
+
+    /// Sets the base color of the points in the scanning UI
+    /**
+     * The parameters allow you to set the Red, Green and Blue colors 
+     * for the Points. They should be normalized values between 0 and 1.
+     * Note that this call triggers the keypoint texture to be recreated and
+     * it should thus be avoided to called this every frame.
+     */
+    virtual void setUIPointColor(float r, float g, float b) = 0; 
+};
+
+} // namespace QCAR
+
+#endif //_QCAR_TARGET_FINDER_H_
